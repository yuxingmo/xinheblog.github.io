{"meta":{"title":"时光之笔","subtitle":"正在寻求自救的懒癌晚期患者","description":"Xin He's blog","author":"Xin He","url":"hxblog.top","root":"/"},"pages":[{"title":"关于","date":"2019-05-22T01:47:28.472Z","updated":"2019-05-22T01:47:28.472Z","comments":false,"path":"about/index.html","permalink":"hxblog.top/about/index.html","excerpt":"","text":"喜欢动漫，虽然已经快奔四了… ✨ 😱 伪球迷，喜欢红魔，虽然现在看球越来越少了 热爱编程与研究算法，虽然基础极差 研究方向：CFD，FSI 包括：LBM(格子波尔兹曼方法)，IBM（浸入边界方法），IB-LBM，Palabos 欢迎大家与本博客交流！ 创建了一个群，关于LBM和Palabos的，感兴趣的可以加一下。希望能成为大家交流共同进步的土壤。 点击链接加入群聊【时光之笔的LBM交流群】：https://jq.qq.com/?_wv=1027&k=5y6CDNi QQ群号码：620660368 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2018-06-03T02:21:07.000Z","updated":"2018-06-03T02:21:26.000Z","comments":false,"path":"categories/index.html","permalink":"hxblog.top/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2018-06-03T02:20:23.000Z","updated":"2018-06-03T02:20:57.000Z","comments":false,"path":"tags/index.html","permalink":"hxblog.top/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"与拖延症斗智斗勇","slug":"与拖延症斗智斗勇","date":"2019-07-15T09:37:09.000Z","updated":"2019-07-15T10:47:17.540Z","comments":true,"path":"post/64984505.html","link":"","permalink":"hxblog.top/post/64984505.html","excerpt":"由于最近一个月以来效率比较低，所以到处鸡血来打。 在这些过程中也不能说没有收获，因此想写个小小的总结。 这里来聊一聊关于我和拖延症斗智斗勇的故事。","text":"由于最近一个月以来效率比较低，所以到处鸡血来打。 在这些过程中也不能说没有收获，因此想写个小小的总结。 这里来聊一聊关于我和拖延症斗智斗勇的故事。 1 起因很长一段时间没有更新博客，因为我一直都在修改论文。论文一审回来大概是在六月初，但是改到现在还没有改完。其实按照正常的速度，一个月是足够的。但是正是“拖延症”这个家伙，害的我效率极其低下。 作为一个大龄博士，我认为这是非常可怕的，于是想找些视频来打打鸡血，吸口药。虽然很多人对此表示不认同，但是在某种程度上还是唤起了我的一些斗志。嗯，斗志。 提到斗志，我觉得我已经离他很远了。对，我早就不是那个年轻的时候什么都不怕什么都敢做什么都想学的贪心的小伙子了。 前几天，监考日语，看到一群98年99年的年轻人，在考场里奋笔疾书的样子，那一刻真的对自己变得老了这一事实更一次深刻的认识到了。 不觉感叹，人生有几个这样的时候啊！ 当然，老年人就要有老年人的觉悟。既然精力激情和集中力都不及年轻人，那就要用一些更加有智慧的方法。于是我就开始抽空看一些关于拖延症和自律的一些科普视频和实战视频。在里面搜集一些对自己有用的东西。 于是，就有了今天这篇文章。 2 搬运2个油管视屏这两个油管视屏，一个是从拖延症和自律的科学来开始介绍，偏向于理论。而另一个更多的偏向于实操。大家看看就知道我说的是哪个了。 推荐这两位油管的up主。艾尔文主要是从书中的理论出发，ElenaLin_青青更多的是从实际操作上出发。看完艾尔文的视频会知道一些和心理学相关的知识。看完后者的视频会让你有想好好工作的冲动。 今天就暂时讲这么多，因为我要去赶火车啦。还有一些东西要收拾。 下次会继续这个议题： 观点：记录一些关于拖延症，自律，自控力相关的观点； 方法论：如何将这些观点形成具体的方法。说一说我自己构造的这个体系。这也算是实操吧； 工具：介绍方法论中用到的工具。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"生活","permalink":"hxblog.top/categories/生活/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"hxblog.top/tags/随笔/"}]},{"title":"通知：关于Palabos2.0开发文档的域名变更","slug":"通知：关于Palabos2-0开发文档的域名变更","date":"2019-07-15T09:33:25.000Z","updated":"2019-07-26T05:52:23.278Z","comments":true,"path":"post/2bc95c51.html","link":"","permalink":"hxblog.top/post/2bc95c51.html","excerpt":"Palabos2.0 开发文档的域名变更了，新域名是：http://palibos.huasaiou.com。 另外，我的邮箱也变更了。","text":"Palabos2.0 开发文档的域名变更了，新域名是：http://palibos.huasaiou.com。 另外，我的邮箱也变更了。 另外，由于我之前留的邮箱：lepas222@hotmail.com并不是很常用，以及被微软暂停使用了，要手机号验证，我懒得弄，干脆不用了。以至于有些朋友的来信长时间没有回复。在这里为这些朋友表示抱歉。 如果有需要交流的，可用通过以下方式联系我： 日常邮箱：lepas222@163.com 也可以加本博客的交流QQ群：620660368 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"置顶","slug":"置顶","permalink":"hxblog.top/tags/置顶/"}]},{"title":"如何做好一件事","slug":"如何做好一件事","date":"2019-07-01T10:43:56.000Z","updated":"2019-07-15T10:47:46.641Z","comments":true,"path":"post/43b6b040.html","link":"","permalink":"hxblog.top/post/43b6b040.html","excerpt":"对于一个很容易分心的人来说，做好一件事情其实是比较费时的。","text":"对于一个很容易分心的人来说，做好一件事情其实是比较费时的。 我是一个容易分心的人。 很容易被打扰。 很容易就分神去做其他的事情了。 有时候挺无奈的。因为我的注意力很不集中。 很难沉下心来高效率的做一件事情。 我觉得还是有必要改变一些自己的习惯。 在做一件事之前，首先确认以下几个方面的内容： 找对方法：对要做的这个事情定性，明确交付件，确定怎么样做这件事情会比较好。 细分：对这件事情进行进一步细分，明确每一步的细分交付件。 定时：对每个子任务进行番茄钟划定。 第一步从战略上重视。第二步从战术上重视。第三部考验执行。 大学的时候，我曾经参加过一个关于时间管理的讲座。 里面有一点我比较认同。 就是计划的好坏，在于其可执行性是否足够。 简单的计划执行起来是最难的。 细节更多的计划可以帮助你执行的更快，更有成效。 但是并不是越繁复越好。因为越繁复的计划灵活性越差。 不过如果是针对某个单独的任务来说，对任务进行细节的计划是可取的。 丰富的细节和步骤保证了执行的可行性，番茄钟的划分保证了计划的可靠性。 现在的生活就像脚踩西瓜皮，走到哪里算哪里。毫无计划性，也毫无效率。说白了，就是生活得欠缺思考。 越来越麻木，越来越不喜欢思考，越来越喜欢凭借经验，越来越丧失了对生活的热爱和对世界的好奇。 这是灾难性的。 所以，我希望我每天都能够有所思考。 而实现这个最好的方式，就是每天过得有计划性。每天有复盘的习惯。 既然已经明白了这个道理，那么便自勉吧。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"生活","permalink":"hxblog.top/categories/生活/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"hxblog.top/tags/随笔/"}]},{"title":"学习笔记：包含外力项的LBM模型","slug":"学习笔记：包含外力项的LBM模型","date":"2019-06-13T13:55:42.000Z","updated":"2019-06-15T00:04:50.207Z","comments":true,"path":"post/ab1fff7c.html","link":"","permalink":"hxblog.top/post/ab1fff7c.html","excerpt":"在IBM中，将结构对流体的作用等效为体积力。传统的LBM方程不包含这个体积力。如果需要考虑这个体积力的话，其相应的控制方程也需要发送变化。 体积力对方程的影响主要集中在粒子的速度上。","text":"在IBM中，将结构对流体的作用等效为体积力。传统的LBM方程不包含这个体积力。如果需要考虑这个体积力的话，其相应的控制方程也需要发送变化。 体积力对方程的影响主要集中在粒子的速度上。 1 控制方程在LBE中考虑作用力的影响，直观的方法是在演化方程中增加一个作用力项： $$f_{i}\\left(x+c_{i} \\delta t, t+\\delta t\\right)-f_{i}(x, t)=-\\frac{1}{\\tau}\\left[f_{i}(x, t)-f_{i}^{e q}(x, t)\\right]+\\delta t F_{i}$$ 作用力项中的不同形式，导致不同的作用力模型。这里考虑的是郭照力老师提出来的CZS模型。 在LBGK模型中，发送一次碰撞的时间为： $$\\tau \\delta$$ 由作用力引起的流体动量变化为： $$\\mathbf{F} \\tau \\delta$$ 因此，可以看到，体积力的影响主要是影响粒子的宏观速度。通过改变平衡态分布函数，来考虑作用力的影响。而平衡态分布函数，是密度与宏观速度的函数。即： $$f_{i}^{e q}=E_{i}\\left(\\rho, \\mathbf{u}^{*}\\right)$$ 其中带星号的u表示的是平衡态速度。其值与普通的LBGK方程中的平衡态速度不一样，普通的平衡态速度： $$\\rho \\mathbf{u}=\\sum_{i} \\mathbf{e}{i} f{i}$$ 修正后的平衡态速度： $$\\rho \\mathbf{u}^{*}=\\sum_{i} \\mathbf{e}{i} f{i}+\\frac{\\delta t}{2} \\mathbf{F}$$ 修正后的平衡态速度与标准的平衡态速度相比，多了关于体积力的一项。这实际上是对碰撞前后的速度的一个平均。 GZS模型的流体宏观速度和修正的平衡态速度一样： $$\\rho \\mathbf{u}=\\sum_{i} \\mathbf{e}{i} f{i}+\\frac{\\delta t}{2} \\mathbf{F}$$ 力源项的计算： $$F_{i}=\\left(1-\\frac{1}{2 \\tau}\\right) \\omega_{i}\\left[\\frac{\\mathbf{e}{i}-\\mathbf{v}}{c{s}^{2}}+\\frac{\\left(\\mathbf{e}{i} \\cdot \\mathbf{v}\\right)}{c{s}^{4}} \\mathbf{e}_{i}\\right] \\cdot \\mathbf{F}$$ 总结来看，其控制方程主要是4个： 包含外力的LBE方程: $$f_{i}\\left(\\mathbf{x}+\\mathbf{e}{i} \\Delta t, t+\\Delta t\\right)-f{i}(\\mathbf{x}, t)=-\\frac{1}{\\tau}\\left(f_{i}(\\mathbf{x}, t)-f_{i}^{e q}(\\mathbf{x}, t)\\right)+F_{i} \\Delta t\\tag{1.1}$$ 修正的平衡态速度方程: $$\\rho \\mathbf{u}^{*}=\\sum_{i} \\mathbf{e}{i} f{i}+\\frac{\\delta t}{2} \\mathbf{F}\\tag{1.2}$$ 修正的流体速度方程： $$\\rho \\mathbf{u}=\\sum_{i} \\mathbf{e}{i} f{i}+\\frac{\\delta t}{2} \\mathbf{F}\\tag{1.3}$$ 体积力计算方程： $$F_{i}=\\left(1-\\frac{1}{2 \\tau}\\right) \\omega_{i}\\left[\\frac{\\mathbf{e}{i}-\\mathbf{v}}{c{s}^{2}}+\\frac{\\left(\\mathbf{e}{i} \\cdot \\mathbf{v}\\right)}{c{s}^{4}} \\mathbf{e}_{i}\\right] \\cdot \\mathbf{F}\\tag{1.4}$$ 平衡态分布函数： $$f_{i}^{e q}=E_{i}\\left(\\rho, \\mathbf{u}^{*}\\right)\\tag{1.5}$$ 2 离散方程离散主要是针对包含外力的LBE方程，即对以下方程进行离散： $$f_{i}\\left(\\mathbf{x}+\\mathbf{e}{i} \\Delta t, t+\\Delta t\\right)-f{i}(\\mathbf{x}, t)=-\\frac{1}{\\tau}\\left(f_{i}(\\mathbf{x}, t)-f_{i}^{e q}(\\mathbf{x}, t)\\right)+F_{i} \\Delta t \\tag{2.1}$$ 碰撞：碰撞和此前的LBGK变化不大，只是增加了体积力而已： $$f_{i}^{\\star}(\\mathbf{x}, t)=f_{i}(\\mathbf{x}, t)-\\frac{\\Delta t}{\\tau}\\left[f_{i}(\\mathbf{x}, t)-f_{i}^{e q}(\\mathbf{x}, t)\\right]+F_{i} \\Delta t \\tag{2.2}$$ 带星号的分布函数表示的是碰撞之后的分布函数。此时并没有进行时间推移 迁移： $$f_{i}\\left(x+c_{i} \\Delta t, t+\\Delta t\\right)=f_{i}^{\\star}(x, t) \\tag{2.3}$$ 3 关于与IBM的结合包含外力项的流体方程，其最大的作用在于实现IBM，即浸入边界法。因为浸入边界的核心就是把边界对流体的作用等效为一个力源项。 因此，我们来看，在和IBM结合的时候，如何来使用。实际上，不同的边界力计算模型，会采用不同的算法。这里我们首先只考虑一个简单的情况，即边界力采用罚方法，或者解析力法从结构域直接求得。 首先我们假设边界力是已经求出来了。即F我们已知。 这样，我们就要分别通过根据式1.2，1.3计算出平衡态速度u*以及宏观流体速度u； 根据计算得到的平衡态速度u*，根据式1.5计算得到平衡态分布函数feq； 根据宏观流体速度u，通过式1.4计算得到离散的体积力Fi； 把离散的体积力Fi和平衡态分布函数feq带入到式2.2，执行碰撞操作； 执行迁移操作，至此完成一次循环计算。 4 Palabos里的外力项模型4.1 包含外力项模型的动态在Palabos里面，包含外力项模型的动态为：ExternalForceDynamics 其继承关系图如下图： ExternalForceDynamics的继承关系 我们来看看，ExternalForceDynamics下的计算宏观速度的两个方法：computeVelocity和computeVelocityExternal。先看第一个： 123456789101112131415templatevoid ‪ExternalForceDynamics::computeVelocity ( ‪Cell const& cell, ‪Array& u ) const{ T rhoBar; ‪Array force, j; ‪momentTemplates::get_rhoBar_j(cell,rhoBar, j); force.‪from_cArray(cell.‪getExternal(Descriptor::ExternalField::forceBeginsAt)); T invRho = Descriptor::invRho(rhoBar); for (‪plint iD = 0; iD < Descriptor::d; ++iD) { u[iD] = j[iD]*invRho + force[iD]/(T)2; }} 这个是ExternalForceDynamics下面的计算宏观速度的其中一个方法，输入是单元的引用，及一个速度矢量。通过该方法，可以计算单个单元的宏观速度。可以看到，其宏观速度的计算方法如式1.3. 其中：momentTemplates::get_rhoBar_j(cell,rhoBar, j);从cell里面取得rhoBar和j，用于后续的计算。force.‪from_cArray(cell.‪getExternal(Descriptor::ExternalField::forceBeginsAt));从cell里面取得外力，用于后续的计算。 第二个宏观速度的计算方法computeVelocityExternal ： 1234567891011121314templatevoid ‪ExternalForceDynamics::computeVelocityExternal ( ‪Cell const& cell, T rhoBar, ‪Array const& j, ‪Array& u ) const{ ‪Array force; force.‪from_cArray(cell.‪getExternal(Descriptor::ExternalField::forceBeginsAt)); T invRho = Descriptor::invRho(rhoBar); for (‪plint iD = 0; iD < Descriptor::d; ++iD) { u[iD] = j[iD]*invRho + force[iD]/(T)2; }} computeVelocityExternal 这个方法和上面的几乎一样，不一样的在于computeVelocityExternal中的rhobar，j，都是从外部给与，而不是从cell中获得。 4.2 体积力的计算接下来，我们来看看体积力的计算，即式1.4的计算。体积力的计算主要源自于addGuoForce。addGuoForce这个方法有好几种存在形式，通用的形式存在于模板externalForceTemplatesImpl中。其代码如下： 1234567891011121314151617181920212223242526static void ‪addGuoForce( ‪Array& f, T* externalScalars, ‪Array const& u, T omega, T amplitude ) { static const int forceBeginsAt = Descriptor::ExternalField::forceBeginsAt; T* force = externalScalars + forceBeginsAt; for (‪plint iPop=0; iPop < Descriptor::q; ++iPop) { T c_u = T(); for (int iD=0; iD‪computeRhoBar(cell); ‪Array u, j; this->‪computeVelocity(cell, u); T rho = Descriptor::fullRho(rhoBar); for (‪plint iD = 0; iD < Descriptor::d; ++iD) { j[iD] = rho * u[iD]; } T uSqr = ‪dynamicsTemplates::bgk_ma2_collision(cell, rhoBar, j, this->getOmega()); ‪externalForceTemplates::addGuoForce(cell, u, this->getOmega(), (T)1); if (cell.‪takesStatistics()) { ‪gatherStatistics(statistics, rhoBar, uSqr); }} 输入参数：cell，即单元，statistics是一个BlockStatistics类型的变量。 第一句T rhoBar = this->‪computeRhoBar(cell);计算宏观速度u。然后接下来是计算j，即rho*u。把这个j带入碰撞计算式dynamicsTemplates::bgk_ma2_collision(cell, rhoBar, j, this->getOmega());可以对该单元执行碰撞处理。 值得注意的是，这里面在执行完标准的碰撞之后，还执行了一项：addGuoForce。这个命令相当于把体积力加到的分布函数上。 看式2.2，前面的标准碰撞相当于把 $ f_{i}^{\\star}(\\mathbf{x}, t)=f_{i}(\\mathbf{x}, t)-\\frac{\\Delta t}{\\tau}\\left[f_{i}(\\mathbf{x}, t)-f_{i}^{e q}(\\mathbf{x}, t)\\right] $实现了，后面的addGuoForce相当于把计算得到的体积力的影响加到了分布函数上，实际上是Fi*dt这部分。 来看看addGuoForce的代码： 1234567891011121314151617181920212223242526static void ‪addGuoForce( ‪Array& f, T* externalScalars, ‪Array const& u, T omega, T amplitude ) { static const int forceBeginsAt = Descriptor::ExternalField::forceBeginsAt; T* force = externalScalars + forceBeginsAt; for (‪plint iPop=0; iPop < Descriptor::q; ++iPop) { T c_u = T(); for (int iD=0; iDsetExternalField(*this, pos, size, ext); } cell里面的setExternalField调用的是dynamic里面的setExternalField。 Dynamic里面的setExternalField如下： 12345678910template void ‪Dynamics::setExternalField ( ‪Cell& cell, ‪plint pos, ‪plint size, const T* ext) { ‪PLB_PRECONDITION(pos+size { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"LBM","slug":"LBM","permalink":"hxblog.top/tags/LBM/"},{"name":"Palabos","slug":"Palabos","permalink":"hxblog.top/tags/Palabos/"}]},{"title":"学习笔记：Palabos（8）：DomainFunctionalXD解析","slug":"学习笔记：Palabos（8）：DomainFunctionalXD解析","date":"2019-06-12T08:08:31.000Z","updated":"2019-06-15T00:04:50.206Z","comments":true,"path":"post/9bc49a96.html","link":"","permalink":"hxblog.top/post/9bc49a96.html","excerpt":"DomainFunctionalXD本质是一种数据处理器，是作用域函数类。用来对设计某个特别的域，并可以根据这个作用域函数类来对这个特别的域进行动态赋予。","text":"DomainFunctionalXD本质是一种数据处理器，是作用域函数类。用来对设计某个特别的域，并可以根据这个作用域函数类来对这个特别的域进行动态赋予。 1 定义来看看DomainFunctional2D： 12345struct ‪DomainFunctional2D { virtual ‪~DomainFunctional2D() { } virtual bool ‪operator() (‪plint iX, ‪plint iY) const =0; virtual ‪DomainFunctional2D* ‪clone() const =0;}; 里面最关键的就是重载的运算符‪()。operator重载了函数调用运算符()。输入是iX和iY。这两个是cell的索引。根据cell的索引来决定返回的是true还是false。重载了()之后，在调用构造函数DomainFunctional2D时就可以实现重载后的功能。 关于重载运算符operator在对函数调用运算符()的重载有一个例子，在[菜鸟教程里][https://www.runoob.com/cplusplus/function-call-operator-overloading.html]。 2 举例来自文档)中的例子： 1234567891011121314151617181920templateclass CylinderShapeDomain2D : public DomainFunctional2D {public: CylinderShapeDomain2D(plint cx_, plint cy_, plint radius) : cx(cx_), cy(cy_), radiusSqr(util::sqr(radius)) { } // The function-call operator is overridden to specify the location // of bounce-back nodes. virtual bool operator() (plint iX, plint iY) const { return util::sqr(iX-cx) + util::sqr(iY-cy) { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"LBM","slug":"LBM","permalink":"hxblog.top/tags/LBM/"},{"name":"Palabos","slug":"Palabos","permalink":"hxblog.top/tags/Palabos/"}]},{"title":"学习笔记：Palabos（7）:IncomprFlowParam","slug":"学习笔记：Palabos（7）-IncomprFlowParam","date":"2019-06-02T15:39:22.000Z","updated":"2019-06-11T13:33:53.578Z","comments":true,"path":"post/a0a2d3bf.html","link":"","permalink":"hxblog.top/post/a0a2d3bf.html","excerpt":"IncomprFlowParam是一个代表不可压缩流体的参数的类。包括流体设定的一些基本信息，比如速度，雷诺数，格子长度，和格子分辨率等。","text":"IncomprFlowParam是一个代表不可压缩流体的参数的类。包括流体设定的一些基本信息，比如速度，雷诺数，格子长度，和格子分辨率等。 1 private参数它包含的参数如下： 参数调用关系 类型 变量名称 解释 T physicalU 物理无量纲速度 T latticeU 格子速度：正比于马赫数 T Re 雷诺数 T physicalLength 物理无量纲特征长度 plint resolution 分辨率N，单元数为N+1，因为C++索引从0开始 T lx 格子长度x方向，分辨率的倍数 T ly 格子长度y方向，分辨率的倍数 T lz 格子长度z方向，分辨率的倍数 值得注意的是： 格子粘度，以及松弛因子，都不包括在上面的private参数里面，因为这些参数都可以根据上面的数据直接计算得到。看第二节。 分辨率resolution一般都是在特征长度方向。比如在Poiseuille流中，特征长度就是流场的宽度，因此分辨率就是指在这个物理量上的分辨率。 lx,ly,lz这三个参数都是无量纲参数。其值一般是分辨率resolution的倍数。比如在Poiseuille流中，流场的宽度方向的分辨率是N，lx=1的话就意味着流场宽度方向的分辨率就是N，ly=2的话就意味着长度方向的分辨率是2N。 物理特征速度physicalU和物理特征长度physicalLength默认为1。两者都是无量纲化的。 假如物理无量纲长度为L，那么： $$d x=\\frac{L}{N}$$ 其中$d x$代表单位格子宽度（这个也是无量纲的量）。${L}$代表的是physicalLength，即物理无量纲特征长度。N代表的是分辨率，即resolution。 可以这样说，Palabos本质上是把无量纲方程作为离散的，也就是Palabos里面的的数据量都是无量纲的。这个问题牵扯到LBM的单位设置。以后有时间可以详细说说。 2 常用方法 getLatticeNu()计算格子粘度： 1return ‪getLatticeU()*(T)‪getResolution()/‪Re; $$N u=\\frac{U_{\\text {lattice}} \\cdot N}{\\operatorname{Re}}$$ getTau()计算松弛时间： 1return (T)3*‪getLatticeNu()+(T)0.5; $$\\tau=3 \\cdot N u+\\frac{1}{2}$$ getOmega()计算Omega： 1return (T)1 / ‪getTau() $$\\omega=\\frac{1}{\\tau}$$ getDeltaX()计算格子间距： 1return (T)‪getPhysicalLength()/(T)‪getResolution(); $$d x=\\frac{L}{N}$$ getLx()计算Lx，也就是X方向上的无量纲长度： 1return ‪getPhysicalLength()*‪lx; nCell()计算l长度下有几个单元。 1‪plint ‪nCell(T l) const { return (int)(l/‪getDeltaX()+(T)0.5); } getNx()计算x方向有几个单元： 1plint ‪getNx(bool offLattice=false) const { return ‪nCell(‪getLx())+1+(int)offLattice; } 这里调用了nCell函数。offLattice是一个布尔型，目前作用不明。如果不考虑这个offLattice的话，把所有参数代进去： $$(\\text { int })\\left(\\frac{\\text { getPhysicalLength } \\cdot 1 \\mathrm{x}}{\\text { getDelta } \\mathrm{X}}+0.5\\right)+1$$ $$(\\text { int })\\left(\\frac{\\text { physicalLength.lx }}{\\text { physicalLength/resolution }}+0.5\\right)+1$$ $$(\\text { int })(\\text { resolution } \\cdot 1 \\mathrm{x}+0.5)+1$$ 可以看出，其实和physicalLength并无关系。不是很清楚为什么要这么做。直接让resolution*lx+1不就行了吗？ ## getDeltaT()计算时间步： 1T ‪getDeltaT() const { return ‪getDeltaX()*‪getLatticeU()/‪getPhysicalU(); } $$d t=\\frac{L}{N} \\times \\frac{U_{\\text {latice}}}{U_{\\text {phiscal}}}$$ 默认物理长度L=1，物理速度physicalU=1。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"LBM","slug":"LBM","permalink":"hxblog.top/tags/LBM/"},{"name":"Palabos","slug":"Palabos","permalink":"hxblog.top/tags/Palabos/"}]},{"title":"学习笔记：Palabos（6）：数据处理器相关","slug":"学习笔记：Palabos（6）：数据处理器相关","date":"2019-05-29T07:46:03.000Z","updated":"2019-06-01T14:53:44.789Z","comments":true,"path":"post/8df3db90.html","link":"","permalink":"hxblog.top/post/8df3db90.html","excerpt":"数据处理器用来处理非局部操作。我们知道Dynamic处理局部操作，数据处理器来处理Dynamic完成不了的工作。数据处理器比较难，我之前以及接触到了一些，是一个非常庞大的东西。 鉴于能力有限，本文的讨论仅基于用户文档中关于数据处理的部分，以及参考了Palabos V2.0的开发文档。","text":"数据处理器用来处理非局部操作。我们知道Dynamic处理局部操作，数据处理器来处理Dynamic完成不了的工作。数据处理器比较难，我之前以及接触到了一些，是一个非常庞大的东西。 鉴于能力有限，本文的讨论仅基于用户文档中关于数据处理的部分，以及参考了Palabos V2.0的开发文档。 1 数据处理器的作用Dynamic类和数据处理器是Palabos构建程序的基础部分，文档上说是Palabos的螺钉螺母，就是这个意思。Dynamic是处理LBM单元计算，也就是局部操作：比如计算平衡态分布函数，碰撞等操作。而数据处理器是一个更加通用，且具有并行化特征的数据处理方法。只要不涉及边界，细化网格，并行程序或者其他一些Palabos里复杂的东西，Dynamic还是相对简单的。 数据处理器解决除了Dynamic解决不了的一切问题。处理模型中的非局部部分，在标量场和张量场上执行操作，并且处理多块网格之间的耦合，并且为了增加性能，它们必须高效而且满足并行化的特征。 因此数据处理器理解起来会比较困难，种类繁多，层层的迭代调用，并且包含了很多复杂的C++用法。好在不需要全部理解它们。Palabos的封装性做得很好，很大程度上我们需要去知道其调用方法即可以解决一般性的问题。 当在处理标量场和张量场时，数据处理器的重要性尤其明显。与block-lattice不同，这些场没有智能单元，比如lattice-block都有一个引用指向其dynamic。因此，数据处理器是对它们执行集体操作的唯一有效方式。比如考虑三维的速度张量场：TensorField3D velocity(其中每个单元都有Array 类型的速度变量)，可以通过调用函数computeVelocity从LB模拟获得这样的速度场。假使我们需要计算velocity的空间导数，那么只能用数据处理器来进行。因为数据处理器是并行的、可拓展的、高效的。例如computeVorticity()和computeStrainRate()那样。 2 数据处理器的分类根据用途，数据处理器可分为三大类： 将动态对象分配给lattice的子域，初始化分布函数等等，这些方法在密度和速度的初始值和定义边界条件一节中进行了解释，这些函数在附录中中列出。 实现特定的物理模型，许多模型是预先设定好的。 用于数据评估，也就是后处理。比如computeVelocity这些 3 定义自己的数据处理器3.1 用于局部操作的数据处理器用于局部操作的数据处理器通常出现于Palabos内置的数据处理器或者Dynamic无法满足条件的情况。对于局部的数据操作，Palabos提供了一些抽象的接口：OneCellFunctionalXD，OneCellIndexedFunctionalXD。应该在这些接口上去实现你要的功能，也就是继承他们，并实现它的虚方法，而不是去重写这部分代码。 比如通过实现OneCellFunctionalXD可以执行局部化的操作，而不用访问周围的单元。如果操作取决于周围的单元，则可以继承OneCellIndexedFunctionalXD并实现该方法 这样的案例可以在examples / showCases / multiComponent2d中找到相应的示例程序。该示例程序中需要定制的初始化过程来访问lattice的外部标量以进行热仿真。 3.2 用于矩阵中的数据处理器当处理的对象不再是一个局部的单元而是一个矩阵时，Palabos也提供了相应的接口，类似于3.1节的那样，是一些抽象的接口。为了实现你自己的功能，需要继承他们并且实现里面的方法。 在矩阵上执行操作一般是在矩阵的所有元素执行某个循环来达到目的。如果矩阵的内存被分为多块，就像Palabos里的Multiblock一样，并且这些组件分布在并行机器的节点上，这样你的循环也需要分为几个小的循环。Palabos的数据处理器的目的就是为了自动执行这些细分，然后它提供单个域的坐标，并且要求在这些单个的域上执行操作，而不是整个完整的域。 下面是一个例子，假设要操作一个域中单元格的分布函数，比如将f5和f1的值互换: 123456789101112131415templateclass Invert_1_5_Functional2D : public BoxProcessingFunctional2D_L { public: // ... implement other important methods here. void process(Box2D domain, BlockLattice2D& lattice) { for (plint iX=domain.x0; iX","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"LBM","slug":"LBM","permalink":"hxblog.top/tags/LBM/"},{"name":"Palabos","slug":"Palabos","permalink":"hxblog.top/tags/Palabos/"}]},{"title":"免费开源的FTP增量同步工具：FreeFileSync","slug":"免费开源的FTP增量同步工具：FreeFileSync","date":"2019-05-28T10:25:18.000Z","updated":"2019-05-28T10:47:03.533Z","comments":true,"path":"post/bd68ef14.html","link":"","permalink":"hxblog.top/post/bd68ef14.html","excerpt":"这次分享一款PC软件：freefilesync，可以实现向支持FTP的虚拟主机增量上传。","text":"这次分享一款PC软件：freefilesync，可以实现向支持FTP的虚拟主机增量上传。 Hexo的ftp不好用了，突然就不行了，重装了系统也不行。直接用ftp软件8uftp这种，每次改了文章要上传很久。 找到了这款免费开源的软件：freefilesync 主界面：左右两边既可以设定本地，也可以设定服务器，还支持Google Drive，当然也支持FTP 主界面 同步设置： 同步设置之对比方案 这里我选择对比标准是：文件大小和时间，这比较符合我的需求： 同步设置之对比方案 同步设置之传输方案 同时，我的要去是本地的改变，包括删除和增加修改都要同步到服务器，所以选择镜像。 同步设置之传输方案 在线存储输入FTP地址，端口，用户名和密码就可以连接，注意有子目录的要选择好子目录。 在线存储界面 下载地址 官网下载 百度网盘：bw3a document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"好物推荐","slug":"好物推荐","permalink":"hxblog.top/categories/好物推荐/"}],"tags":[{"name":"FreeFileSync","slug":"FreeFileSync","permalink":"hxblog.top/tags/FreeFileSync/"},{"name":"FTP","slug":"FTP","permalink":"hxblog.top/tags/FTP/"}]},{"title":"学习笔记：Palabosos（5）：运行模拟","slug":"2019-05-22-学习笔记：Palabosos（5）：运行模拟","date":"2019-05-28T02:58:11.000Z","updated":"2019-05-28T14:50:27.950Z","comments":true,"path":"post/92d72c3a.html","link":"","permalink":"hxblog.top/post/92d72c3a.html","excerpt":"翻译了一下官方文档的两个部分，从中选取了一些比较重要的记录下来： 运行模拟部分 输入输出部分","text":"翻译了一下官方文档的两个部分，从中选取了一些比较重要的记录下来： 运行模拟部分 输入输出部分 1 Palabos程序的时间周期LBM采用显式求解器的方法： 碰撞： $$f_{i}^{\\star}(x, t)=f_{i}(x, t)-\\frac{\\Delta t}{\\tau}\\left[f_{i}(x, t)-f_{i}^{\\mathrm{eq}}(x, t)\\right] \\quad$$ 迁移：$$f_{i}\\left(x+c_{i} \\Delta t, t+\\Delta t\\right)=f_{i}^{*}(x, t)$$ 可以看到，在碰撞步没有发生时间推进，得到的是一个中间变量$f_{i}^{\\star}(x, t)$。时间推进是在迁移步完成之后进行。 Palabos采用的亦是同样的显式求解方法。 首先，所有流体变量都在时间t定义。此时粒子群处于预碰撞状态（也称为“流入分布函数”）。 碰撞操作符适用于所有单元格。它们现在处于碰撞后状态（也称为“流出变量”）。 流操作符应用于格子。 执行所有数据处理器，以执行非局部操作或格子之间的耦合。 分布函数现在再次处于预碰撞状态，但是时间步往前推了一步：变成t+1。 通过调用方法lattice.collide（）执行碰撞步骤（步骤2），并使用方法lattice.stream（）调用迁移步骤（步骤3 ）。这两个方法也可以组合成对lattice.collideAndStream（）的单个调用。在大多数硬件平台上，collideAndStream（）版本在计算上更有效，因为它只通过格子的内存来执行一次。 可以通过调用方法lattice.executeInternalProcessors（）手动执行数据处理器，如执行，集成和包装数据处理功能部分中所述。然而，这种情况很少发生，因为数据处理器也在函数stream（）和函数collideAndStream（）的末尾自动执行。 如果需要在不执行数据处理的情况下调用stream（）或collideAndStream，例如调试程序，可以使用这些函数的域版本，例如lattice.collideAndStream（lattice.getBoundingBox（））。或者是专门指定一个BoxXD：lattice.collideAndStream（new BoxXd(nx,ny)） 在Palabos中，数据处理器总是在碰撞迁移循环之后执行。因此，在分布函数处于预碰撞状态的时刻，即，总是在碰撞迁移循环之后执行非局部操作。 在设置初始条件之后，要进行初始化。这是通过调用方法lattice.initialize（）来实现的。在开始第一个迭代步骤之前。该方法执行一次数据处理器，并在块内执行内部通信步骤，以保证其内部状态一致。 2 评估数据建议仅在系统处于预碰撞状态（进入群体）时才计算流体动力学变量。虽然这种区别对于保守变量密度和速度并不重要（它们在碰撞前和碰撞后状态相同），但对于非保守变量（如应力张量）非常重要。只有当它们在预碰撞状态下计算时，非守恒速度矩才能与流体动力学变量相关。请注意，如果使用方法collideAndStream（），则不会有出错的风险，因为无论如何都无法访问冲突后变量。 计算平均能量： 1pcout 10 20 30 0.023 0.01 Dirichlet 0 0.1 0.2 0.3 0.4 0.4 0.3 0.2 0.1 0 在Palabos里面这样进行解析： 123456789101112131415161718192021222324252627282930313233try { // Open the XMl file. XMLreader xmlFile(\"myInput.xml\"); // It's good policy to flush the content of the XML // file to the terminal, so that in future, when // you check the program's output, you remember // which parameters where used. pcout { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"LBM","slug":"LBM","permalink":"hxblog.top/tags/LBM/"},{"name":"Palabos","slug":"Palabos","permalink":"hxblog.top/tags/Palabos/"}]},{"title":"学习笔记：Palabosos（4）：边界条件","slug":"学习笔记：Palabosos（4）：边界条件","date":"2019-05-22T13:02:05.000Z","updated":"2019-05-27T14:26:09.335Z","comments":true,"path":"post/8fa2b4d0.html","link":"","permalink":"hxblog.top/post/8fa2b4d0.html","excerpt":"边界条件分为两种，一种是和网格对齐的，直线型的边界条件。一种则是弯曲型的边界条件。这两种边界条件，都可以在Palabos里面轻松实现。","text":"边界条件分为两种，一种是和网格对齐的，直线型的边界条件。一种则是弯曲型的边界条件。这两种边界条件，都可以在Palabos里面轻松实现。 1 网格对齐边界1.1 OnLatticeBoundaryConditionXD类有一些边界条件是局部的，这种情况用Dynamic实现，有些是非局部的，这种通常会产生复合Dynamic，通常要借助于数据处理器。OnLatticeBoundaryConditionXD类相当于提供了一个统一的接口，不管是局部的还是非局部的，或者是这两者都有，这取决于采用的边界条件。不过，不管是什么情况OnLatticeBoundaryConditionXD都有相应的解决方案。 比如可以用下面的语句来实例化一个Zou/He边界条件： 12OnLatticeBoundaryCondition3D < T ，DESCRIPTOR > * boundaryCondition = createZouHeBoundaryCondition3D < T ，DESCRIPTOR > （）; 创建了一个OnLatticeBoundaryCondition3D类的指针boundaryCondition，采用的是createZouHeBoundaryCondition3D方法。createZouHeBoundaryCondition3D函数不属于任何类，位于plb里面的一个函数。其定义为： 123return new BoundaryConditionInstantiator3D (); 可见是返回一个BoundaryConditionInstantiator3D对象。 而BoundaryConditionInstantiator3D对象又是OnLatticeBoundaryCondition3D的子类。继承关系如下图： OnLatticeBoundaryCondition3D的继承关系 Zou/He是用的相当多的一种边界条件。处理速度、密度、压力边界条件的一种方法。属于非平衡态反弹格式。具有二阶精度和良好的数值稳定性。 目前通过OnLatticeBoundaryConditionXD可以实现的边界条件方法有四种： BC Method Regularized BC createLocalBoundaryConditionXD Skordos BC createInterpBoundaryConditionXD Zou/He BC createZouHeBoundaryConditionXD Inamuro BC createInamuroBoundaryConditionXD 四种边界条件的简要介绍可以看官方文档。 利用这些边界条件，可以实现速度Dirichlet边界（所有速度分量具有强加值）和压力边界（施加压力，并且切向速度分量为零）。此外，提出了各种类型的Neumann边界条件。在这些情况下，通过从相邻单元复制该变量的值，以一阶精度施加给定变量的零梯度边界条件。 注：Dirichlet边界条件指函数本身在边界上给定，Neumann边界条件指函数的法向导数在边界上给定。 1.2 常规矩形域的边界这种应该是最多的吧，求解域是一个矩形，或者是一个立方体。 所有OnLatticeBoundaryConditionXD对象都有两个方法：setVelocityConditionOnBlockBoundaries和setPressureConditionOnBlockBoundaries，用于设置位于矩形域上的边界。如果给定2D框边界框边界上的所有节点都实现了Dirichlet条件，请使用以下命令： 123Box2D boundaryBox(x0,x1, y0,y1);boundaryCondition->setVelocityConditionOnBlockBoundaries ( lattice, boundaryBox, locationOfBoundaryNodes ); 这里先是指定了一个boundaryBox，这个boundaryBox就是边界框了。boundaryCondition其实就是此前创建的那个OnLatticeBoundaryConditionXD对象。在这里调用了这个对象的方法setVelocityConditionOnBlockBoundaries。来看看这个方法对用的声明： 12345template void ‪OnLatticeBoundaryCondition2D::setVelocityConditionOnBlockBoundaries ( ‪BlockLattice2D& lattice, ‪Box2D block, ‪Box2D applicationDomain, ‪boundary::BcType bcType ) 结合声明可以知道，第一个参数lattice表示的是创建边界条件所在的block-lattice区域。第二个boundaryBox表示的边界所作用的是一个矩形区域。第三个参数locationOfBoundaryNodes实际上也是一个BoxXD类，它的作用你可以把他看成是一个选择框。如下图所示。locationOfBoundaryNodes 通常用的是一个边。 VCdIbD.png 第四个参数boundary::BcType省略掉了，这是因为有默认参数：dirichlet。所以，除非不是dirichlet条件，可以不需要明指出具体的BcType。BcType是一个枚举类型： 1234enum BcType { dirichlet, neumann, freeslip, density, outflow, normalOutflow } 如果lattice的外框中的某条边作为边界条件，那么代码可以简化如下： 1boundaryCondition - > setVelocityConditionOnBlockBoundaries （lattice ， locationOfBoundaryNodes ）; 这里的locationOfBoundaryNodes 就是一条边。而如果lattice的外框都是边界条件，并且是同样的，那么代码可以写成： 1boundaryCondition - > setVelocityConditionOnBlockBoundaries （lattice ）; 现在，假设长为nx，宽慰ny的block-lattice中的上壁和下壁（包括角）实现自由滑动条件（切向速度分量为零梯度），左壁为Dirichlet条件，右壁为流出条件（所有速度分量的零梯度）。则代码实现为： 1234567891011121314Box2D inlet(0, 0, 2, ny-2);//入口Box2D outlet(nx-1, nx-1, 2, ny-2);//出口Box2D bottomWall(0, nx-1, 0, 0);//上壁面Box2D topWall(0, nx-1, ny-1, ny-1);//下壁面//默认Dirichlet条件boundaryCondition->setVelocityConditionOnBlockBoundaries ( lattice, inlet );boundaryCondition->setVelocityConditionOnBlockBoundaries ( lattice, outlet, boundary::outflow );boundaryCondition->setVelocityConditionOnBlockBoundaries ( lattice, bottomWall, boundary::freeslip );boundaryCondition->setVelocityConditionOnBlockBoundaries ( lattice, topWall, boundary::freeslip ); 如果边界条件不在lattice的外边，那么需要增加一个BoxXD来进行限定。就像那种最复杂的情况。 1.3 BcType前面提到，BcType是一个命名空间plb:boundary下面的枚举类型。下面是各种不同边界条件的物理含义。 velocity boundaries Note boundary::dirichlet (default value) Dirichlet condition: imposed velocity value. boundary::outflow or boundary::neumann Zero-gradient for all velocity components. boundary::freeslip Zero-gradient for tangential velocity components, zero value for the others. boundary::normalOutflow Zero-gradient for normal velocity components, zero value for the others. pressure boundaries Note boundary::dirichlet (default value) Dirichlet condition: imposed pressure value, zero value for the tangential velocity components. boundary::neumann Zero-gradient for the pressure, zero value for the tangential velocity components. 值得注意的是：边界条件不能被覆盖 无法覆盖边界的类型。一旦边界条件被定义为是Dirichlet速度边界条件，它就会保持Dirichlet速度边界条件。将其重新定义为别的边界条件是没有用的。因此，必须仔细定义边界条件，并且分段定义，如上例所示。 不过定义的边界条件的数值是可以随时改变的。 1.4 在Dirichlet边界上设置速度或压力值使用函数setBoundaryVelocity施加恒定速度值。以下命令在2D域的所有节点上将速度值设置为零，这些节点之前已被定义为Dirichlet速度节点： 1setBoundaryVelocity(lattice, lattice.getBoundingBox(), Array(0.,0.) ); 然而在其他的节点，这个命令没有作用。 如果是要设定压力边界条件，可以采用以下命令： 1setBoundaryDensity(lattice, lattice.getBoundingBox(), 1. ); 在LBM中压力和密度是直接挂钩的，因此设置压力其实就是设置密度。 时变的，与空间相关的速度和压力边界条件也可以实现。具体参考案例：examples/showCases/poiseuille/poiseuille.cpp. 即伯肃叶流动。 值得注意的是，setBoundaryVelocity属于plb下定义的公共函数，不属于任何类。 1.5 内部的和外部的边界条件有时，边界不位于规则的块状区域的表面上。在这种情况下，setVelocityConditionOnBlockBoundaries等函数是无用的，并且必须手动构造边界。下面是一个例子，介绍如何手动构建沿顶壁的自由滑动条件，包括角节点： 12345678910// The automatic creation of a top-wall ...Box2D topWall(0, nx-1, ny-1, ny-1);boundaryCondition->setVelocityConditionOnBlockBoundaries ( topWall, lattice, boundary::freeslip );// can be replaced by a manual construction as follows:Box2D topLid(1, nx-2, ny-1, ny-1);boundaryCondition->addVelocityBoundary1P( topLid, lattice, boundary::freeslip );boundaryCondition->addExternalVelocityCornerNP( 0, ny-1, lattice, boundary::freeslip );boundaryCondition->addExternalVelocityCornerPP( nx-1, ny-1, lattice, boundary::freeslip ); 第一组代码，是自己定义了一个topWall。可以看到这其实就是一个2Dbox的顶线。 第二组代码，用的不是setVelocityConditionOnBlockBoundaries这个方法，而是里面对顶线和角点分别进行边界条件设定的方法。topLid也是一个边，只是不包含两边的角点。 根据角落是凸面还是凹面，区分外角和内角。如下图所示： 内角点和外角点 对于addVelocityBoundary1P后面的1P，其实是代表了边的方向，你可以理解成边的法向量。这样的后缀还有0P，0N，1N。加上1P一共是四个。 代码1P表示：“墙法线指向正y方向” 代码0N标记为“负x方向” 代码1N表示正x方向 代码0P表示y负方向 一般边界的法向量都是指向流场的外面。这和边界条件设定为入口还是出口没有任何关系，这些后缀代表的就是纯几何上的法向量。 在3D中也有类似的东西。 在后面的文章中我会对这些做一个更为细致的介绍。 1.6 总结总结一下设置速度和压力边界条件，以及outflow这种边界条件的基本方法。 首先，要定义一个接口，也就是定义一个OnLatticeBoundaryConditionXD类。采用不同的边界类型算法，采用不同的初始化方法，比如，要让边界采用Zou/H算法来定义计算边界条件，就用createZouHeBoundaryConditionXD来进行初始化； 得到了这个接口之后，调用创建好的这个接口下的成员函数：setVelocityConditionOnBlockBoundaries或者setPressureConditionOnBlockBoundaries，来指定某个边界的类型。其中，指定的边界可能需要某种方式去进行构建； 采用plb:setBoundaryVelocity()这样的方法来设定边界上的具体数值。 至此，完成了边界条件的设定。 2 周期性边界这部分因为没有详细了解过，所以先挖坑吧。 文档 3 反弹边界条件首先，反弹边界条件主要用于对wall实现不可滑移边界条件的实现。 Palabos里面的反弹边界条件的执行方法分为2种：Bounce-Back 1和Bounce-Back 2。 从文档的解读可以知道：Bounce-Back 1实际上对应的是 halfway bounce-back。Bounce-Back 2对应的是 fullway bounce-back。 需要注意的是，不管是Bounce-Back 1还是Bounce-Back 2，都模拟的是边界位于固体节点和流体节点的中间位置。如下图所示： Bounce-Back 1 VS Bounce-Back 2 其中图a表示的是全步长反弹，也就是Bounce-Back 2，图b表示的是半步长反弹，也就是Bounce-Back 1。下面来看看这两者到底有什么区别。 注意：图片来自于文献[1]。 3.1 Bounce-Back 1 VS Bounce-Back 2 Bounce-Back 1是一种半步长反弹（HBC）。 官方文档里指出，这种算法是在边界节点邻近的流体节点进行下一次的碰撞之前，该点的分布函数取上一次碰撞结束后的相反方向的分布函数值，用公式来表达，就是： $f_{3}\\left(x_{N}, t+\\Delta t\\right)=f_{1}^{\\star}\\left(x_{N}, t\\right)$ 其中带星号的分布函数是代表着进行碰撞后得到的值，而不是迁移后得到的值。此外，f1和f3的方向是相反的。 由这个式子及上门的图b可以看到，HBC里面，边界节点是不进行碰撞和迁移的，你可以认为它不对计算起任何作用，也就是说边界节点不用存储任何变量或数值。迁移只在流体节点进行，标准碰撞也只发生在流体节点。此外，靠近边界的这个流体节点迁移不到边界，而是直接反弹了回来。也就是说本来应该有边界迁移过来出来的分布函数，直接在该流体节点反弹了回来。这个分布函数作为下一次碰撞的初始条件。 也可以说，这种算法，反弹是发生在流体节点和固体节点中间的位置。改变了邻近边界节点的流体节点的迁移步骤 Bounce-Back 2是一种全步长反弹（FBC）。 文档中写到，如果将这种反弹的发生地点指定在固体节点中（文档是说的新的节点，实际上就是固体节点），这样，这些节点亦不发生碰撞，而是将碰撞过程代替为反弹过程。注意，这和HBC有一个很大的区别，要在固体边界上执行反弹。这些节点被视为纯算法节点，不具备真实的物理意义，也就是根据这些固体节点计算得到的宏观量（密度，动量）是不准确的。这是由于固体节点只起到一个反弹边界的作用。 用公式表达那么就是如下： 碰撞完成之后，正常迁移至边界节点： $f_{1}\\left(x_{N+1}, t\\right)=f_{1}^{\\star}\\left(x_{N}, t-\\Delta t\\right)$ 边界节点执行反弹规则，实际上是用反弹替换了碰撞： $f_{3}^{\\star}\\left(x_{N+1}, t\\right)=f_{1}\\left(x_{N+1}, t\\right)$ 反弹完成之后，将该分布函数迁移至流体，作为下一次碰撞的初始值： $f_{3}\\left(x_{N}, t+\\Delta t\\right)=f_{3}^{\\star}\\left(x_{N+1}, t\\right)$ 从这些式子，并结合上图可以看到，边界节点不执行碰撞，而是利用反弹来对其进行替换。也就是说，反弹改变了边界节点的碰撞环节，但是并不改变它的迁移环节。 总结一下： Bounce-Back 2是全步长反弹，其对时间精度为1阶。Bounce-Back 1是半步长反弹，对时间精度为2阶； Bounce-Back 2需要固体边界节点，用于存储执行边界反弹和迁移步骤所需要的分布函数。而Bounce-Back 1不需要边界节点存储任何变量； Bounce-Back 2在边界节点上执行正常的迁移，但是碰撞环节被反弹环节所取代，至于靠近边界节点的流体节点，不改变任何运作方式；而Bounce-Back 1在靠近边界节点的流体节点上执行正常的碰撞，但是迁移环节有所改变，本应由边界传递而来的分布函数在这里取值为与其相反方向的碰撞后的分布函数。注意，不是进过迁移后的分布函数。这也就意味着，在执行碰撞之后需要对靠近边界节点的流体节点在那些本应该从边界获得的分布函数进行先赋值，以免迁移过程中发生数值覆盖。 事实上，关于这两种碰撞方法的问题，困扰了我将近五天。 这个问题的复杂在于并不知道Bounce-Back 1和Bounce-Back 2到底代表的什么算法。实际上反弹规则还有很多种，分类方法也不一样，除了全步长和半步长反弹外，根据边界位于节点的哪个位置，有内推移法和外推移法，还有边界就位于边界节点的方法。此外，根据边界节点是否执行标准碰撞过程，还分为标准反弹和修正反弹格式。最终在Krüger, T.K.H.K.等于2017年的出版的书籍上获得了关于半步长和全步长的最为清晰的解答。也为此确定了Bounce-Back 1和Bounce-Back 2的运行机理。 关于这本书，大家可以在Google找到并且看到，由于版权原因，这里就不进行分享了，如果找不到可以取置顶文章里找的本博客的群，在群里询问群主。这本书写的很好，很有深度。广度也不错，我认为是这么多年来看到写的最好的一本关于LBM的教材，教材里面的内容也比较新，能跟得上时代，推荐初学者。 3.2 根据域类定义边界域为了描述一个反弹域，一般是需要确定这个反弹域对应的节点。推荐采用继承一个DomainFunctionalXD类来进行。DomainFunctionalXD是一个矩形或者是立方体的域，其内包含了私有成员变量_iX_和_iX_（或者还有_iX_）。文档中的例子是继承DomainFunctional2D类，创建了一个圆形类，并且重写了operator方法，这个operator方法的作用是获得边界所在的边界节点。 1234567891011121314151617181920templateclass CylinderShapeDomain2D : public DomainFunctional2D {public: CylinderShapeDomain2D(plint cx_, plint cy_, plint radius) : cx(cx_), cy(cy_), radiusSqr(util::sqr(radius)) { } // The function-call operator is overridden to specify the location // of bounce-back nodes. virtual bool operator() (plint iX, plint iY) const { return util::sqr(iX-cx) + util::sqr(iY-cy) > boolMask; 下一步，使用函数defineDynamics的一个版本实例化反弹节点： 1defineDynamics （lattice ， boolMask ， new BounceBack < T ，DESCRIPTOR > ， true ）; 对于上述的操作，并没有自动错误检测。所有使用这个功能，使用者必须要确保标量字段的尺寸与几何文件中的数据大小相对应。 4 问题 问题1： 这里提到了利用反弹边界条件来实现wall的定义，通常wall的条件表现为边界速度为0（静止的wall），那么是否能通过设定Dirichlet边界条件，并使其速度值=0来实现固态的边界条件呢？ 与此同时，我还看到，在LBM中，运动的wall，通常还是用反弹方式来实现： 并没有用Dirichlet。 关于这一点，我认为还是可以通过利用Dirichlet来实现。因为本质上，不管是运动的wall还是静止的wall还是Dirichlet条件。 可以在案例中进行计算试试。 问题2： 在定义反弹边界条件的时候，直接指定了反弹边界节点处应用BounceBack 这种动态行为。而在前面的边界条件的实施的时候，并没有看到指定动态行为的代码。是否这个工作包含在内部的代码以内，还是说通过数据处理器来实现了? 这个目前没有答案，需要进一步去看代码。 话说回来，文章开始写是5月22号，到现在才发布。足足写了5天，还遗留下很多疑惑。果然边界条件还是不好弄啊。 对上述两个问题有清楚的大佬，或者对本文有疑问的同学，均可以在下方留言。 另外，欢迎大家加群一起讨论。 [1]: Krüger, T.K.H.K., The Lattice Boltzmann Method: Principles and Practice. 2017. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"LBM","slug":"LBM","permalink":"hxblog.top/tags/LBM/"},{"name":"Palabos","slug":"Palabos","permalink":"hxblog.top/tags/Palabos/"}]},{"title":"欢迎加入本博客交流群","slug":"欢迎加入本博客交流群","date":"2019-05-22T01:41:54.000Z","updated":"2019-07-15T09:29:53.991Z","comments":true,"path":"post/cd85bfda.html","link":"","permalink":"hxblog.top/post/cd85bfda.html","excerpt":"创建了博客交流群，欢迎加入！ 本站新域名启用！","text":"创建了博客交流群，欢迎加入！ 本站新域名启用！ 本站新域名本站新域名: hxblog.top 原域名：yuxingmo.github.io yuxingmo.github.io托管在Git上，hxblog.top存放在国内的虚拟主机上； 访问速度的话，在国内hxblog.top要快一些； 更新速度的话，yuxingmo.github.io要快一些，因为上传比较简单。服务器上的ftp上传用hexo d会出现问题，所以一般会等到文章修改的比较稳定了才会在hxblog.top上同步。 欢迎大家一起交流因为本博客主要是关于学习记录，因此创建了一个关于学习的交流群，主要是关于LBM和Palabos的，感兴趣的可以加一下。 希望能成为大家交流共同进步的土壤！ 点击链接加入群聊【时光之笔的LBM交流群】：https://jq.qq.com/?_wv=1027&k=5y6CDNi QQ群号码：620660368 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"生活","permalink":"hxblog.top/categories/生活/"}],"tags":[{"name":"置顶","slug":"置顶","permalink":"hxblog.top/tags/置顶/"}]},{"title":"学习笔记：Palabos（3）基本的数据类型","slug":"学习笔记：Palabos（3）基本的数据类型","date":"2019-05-21T07:02:01.000Z","updated":"2019-05-22T01:40:42.199Z","comments":true,"path":"post/cb4fe6c1.html","link":"","permalink":"hxblog.top/post/cb4fe6c1.html","excerpt":"Palabos基本的数据类型，来自于文档的翻译。 包含： BlockXD，格子描述符，Dynamic，数据处理器","text":"Palabos基本的数据类型，来自于文档的翻译。 包含： BlockXD，格子描述符，Dynamic，数据处理器 上周末做汇报，其实材料已经准备好了，没有发上来。这个月要把圆柱扰流的代码搞定，还是任务艰巨。。。 1 BlockXDBlockXD构造表示常规的2D或3D数组（或矩阵）数据，是保存变量的基本结构。关于BlockXD，在之前的文章中介绍了BlockLattice相关的类。但其实BlockXD的子类非常丰富。除了网格变量之外，还有标量张量等。下图是Block结构的继承图。可以看得很清楚。 Block结构的继承图 由图可知，BlockXD派生出了两个大类，一个是AtomicBlockXD，一个是MultiBlockXD。而事实上，由BlockXD还派生出来了MultiGridXD，这一点可以从开发文档里看到。同时，还派生出了一些背景类（或者说是基类，如LatticeBaseXD等）。可以看到，所有类型为“block-lattice”的块都有一个方法collideAndStream（），无论它们是作为multi-block还是atomic-block实现，这个collideAndStream()方法执行格子的碰撞和迁移。 同样，所有multi-block都有一个方法getComponent（），无论它们是block-lattice, scalar-field, 还是tensor-field。 此图中显示的情况称为“多重继承”，因为最终用户类以两种方式从BlockXD继承：其一是通过两大类atomic-block和multi-block路径，其二是背景类，即通过LatticeBaseXD，ScalarFieldBaseXD，TensorFieldBaseXD而来。比如BlockLattice2D这个类，就集成自BlockLatticeBase2D和AtomicBlock2D，而AtomicBlock2D又集成自Block2D。如下图： 可见，BlockXD提供了一切关于求解域，求解域的变量存储等相关的类，并且值得注意的是，其中，BlockLattice这些类具有collide和stream函数，来执行参数的推演。是BlockXD里面最为复杂和重要的类。 2 格子描述子所有BlockXD构造都根据底层数据类型进行模板化。比如下面的代码： 1234567// Construct a 100x100 scalar-field with double-precision floating point values.MultiScalarField2D a(100,100);// Construct a 100x100 scalar-field with single-precision floating point values.MultiScalarField2D b(100,100); 但是对于block-lattice来说，格子还具有其他的模板参数，其中最为重要的是格子描述符，其指定格子的一些拓扑性质（粒子群的数量，离散速度，方向的权重和其他格子常数）。因此，很容易在应用程序中尝试不同的格子： 1234567// Construct a 100x100 block-lattice using the D3Q19 structure.MultiBlockLattice2D lattice1(100,100);// Construct a 100x100 block-lattice using the D3Q27 structure.MultiBlockLattice2D lattice2(100,100); 文档中写道：编写新的网格描述符也很容易（目前没有记录，但你可以查看目录src / latticeBoltzmann / nearestNeighborLattices2D.h中的文件，看看它是如何工作的）。 这非常有用，因为这意味着当您切换到新类型的晶格时，不需要重新编写用于实现BlockLatticeXD的冗长代码部分。 这个论点是Palabos非侵入式程序开发部分中描述的一般概念的一部分。最近邻2D格的描述符。 原则上，由于代码的静态通用性，格子的定义和动态的实现是独立的。 当然，有特例。 例如，使用诸如热通量的高阶矩的动力学需要具有扩展邻域的格子。 另一个例子是D3Q13格子，它只能用它自己的动力学。 不难看出，邻近2D网格描述符（nearestNeighborLattices2D）是通常使用的网格描述符。我顺便查了查nearestNeighborLattices2D这个文件，发现其下面包含了常见的网格描述符：D2Q9Constants、D2Q9DescriptorBase、D2Q9Descriptor、ForcedD2Q9Descriptor等。基本上常见的2D格子描述符都在这里面，其中D2Q9Constants作为父结构体而存在。其中包含了成员变量，里面大部分都是静态的成员变量，没有看到方法。 D2Q9Descriptor 如图是D2Q9描述符的成员变量，可以看到，都是D2Q9的一些固有属性的变量。因此，如果需要开发新的描述符的话，完全可以在此基础上继承。 不过值得注意的是，网格描述符属于结构体模板，并非类模板。 3 动态类（Dynamics）动态类代表了采用的LBM模型。比如是LBGK模型还是MRT模型，或者是包含外力的Guo格式模型。 不同的模型采用不同的平衡态分布函数，乃至离散方式。而动态类Dynamic就是 以下大部分来自于文档的翻译： 在格子Boltzmann模拟的时间迭代期间，block-lattice的所有单元执行局部碰撞步骤，然后执行扩散步骤。扩散步骤是固定的，并且只能通过定义网格描述符中（比如D2Q9Descriptor）的离散速度来影响。然而，碰撞步骤可以完全定制，并且可以实现在不同的单元上执行不同的碰撞方式。通过这种方式，可以在局部调整在网格上模拟的物理特性，并且诸如边界的特定区域可以得到单独的处理。 由于上述目的，比如说要针对不同的边界条件或动力学类型（Dynamics）来执行不同的碰撞模型。那么需要在网格的每个单元保持一个指向Dynamics类型的对象的指针。这个对象提供了碰撞步骤的实现。此外，它还提供了计算宏观变量以及更多有关模型的信息的方法。除了模拟的变量之外，block-lattice的单元格还包含指向Dynamics类型的对象的指针。 该对象最提供了冲突步骤的实现。 此外，它还提供了一种计算宏观变量的方法，用于在不同大小的网格之间重新调整变量的信息，以及更多与模型相关的信息。因此，在Dynamics类中声明的方法列表很长，从这个类继承它似乎很乏味。出于这个原因，Palabos提供了一系列继承自Dynamics的类，其中许多方法是为特定目的预定义的。 因此，定义新的动态类本质上包括在继承层次结构中选择正确的位置，然后重写两个或三个方法。 为了便于说明，此继承图的一部分如下图： Dynamic继承图 Palabos提供了一系列继承自Dynamics的类，其中许多方法是为特定目的预定义的。要学习如何定义新的动力学类，最简单的方法是查看Palabos中定义的一个类。例如，BGK动态定义在文件src / basicDynamics / isoThermalDynamics.hh中。复合动力学（一个修改另一个现有动力学类的行为的类）的一个很好的例子是Smagorinsky动力学，在src / complexDynamics / smagorinskyDynamics.hh中定义。 简单看了看isoThermalDynamics的代码，发现在里面实现了很多动态类的成员方法，比如碰撞，计算宏观变量等。 对于碰撞的实现，动态对象获得对单个单元的引用，因此，碰撞步骤必然是局部的。模拟的非局部成分用数据处理器实现，如下一节所示。 与block-lattice一样，动态对象依赖于两个模板参数，一个浮点参数，一个是网格描述符。通过使用格子描述符中提供的信息，碰撞步骤应以通用的，与网格无关的方式编写。在以通用方式编写算法时显然效率会打折扣，因此通过对给定晶格使用模板特化，可以避免此问题。例如，再次采用BGKdynamics类的实现。通用动态类的碰撞实现通过dynamicsTemplates实现，它在文件src / latticeBoltzmann / dynamicsTemplates.h中定义。然而，针对2D和3D的特殊情况，在文件dynamicsTemplates2D.h和dynamicsTemplates3D.h对碰撞的实现做了重写，这部分代码实现了高效化运行。 3.1 Dynamics的collide方法与BlockLatticeXD的collide方法值得注意的是，在BlockLatticeXD中有了Collide和Stream这两个成员方法，而在Dynamic里面也有两个这样的成员方法。那么到底执行碰撞的是在BlockLatticeXD里面还是Dynamic里面？ 先看看BlockLatticeXD中的collide方法。 BlockLatticeXD有两种形式，看其中一个，后面那个是前面的直接调用，所以看第一个： 12345678910111213template void ‪BlockLattice2D::collide(‪Box2D domain) { ‪PLB_PRECONDITION( (‪plint)Descriptor::q==(‪plint)Descriptor::numPop ); // Make sure domain is contained within current lattice ‪PLB_PRECONDITION( ‪contained(domain, this->getBoundingBox()) ); for (‪plint iX=domain.‪x0; iXgetInternalStatistics());”这一句。这一句调用了一个collide函数，而grid[iX][iY]是个什么的东西呢？ 它的定义是： 1Cell< T, Descriptor > ** grid 可见，grid是一个二维数组，其里面存储的是Cell的对象。所以上一个语句调用的是Cell类里面的成员函数collide。 那么Cell里面的collide是这样的： 12345void ‪collide(‪BlockStatistics& statistics) { ‪PLB_PRECONDITION( ‪dynamics ); ‪dynamics->collide(*this, statistics); } 可以看到里面其实调用的是dynamic里面的collide方法。这样就比较清楚了，BlockLatticeXD里面调用的是对整块格子域进行碰撞操作，而dynamic提供的是具体的方法，也就是每个格子进行碰撞的时候都要调用dynamic里面的这个collide方法。 再来看看dynamic里面的collide方法： 12345678910111213templatevoid ‪BGKdynamics::collide ( ‪Cell& cell, ‪BlockStatistics& statistics ) { T rhoBar; ‪Array j; ‪momentTemplates::get_rhoBar_j(cell, rhoBar, j); T uSqr = ‪dynamicsTemplates::bgk_ma2_collision(cell, rhoBar, j, this->getOmega()); if (cell.‪takesStatistics()) { ‪gatherStatistics(statistics, rhoBar, uSqr); } } 形参里面包括了一个Cell的引用，这说明调用这个方法会改变Cell里面数值。Cell这个类里面最为关键的成员变量就是分布函数f和动态指针dynamics。 第一句对密度进行了声明，第二局声明了一个Array，数组容器。由于“T”代表的是“double”，Descriptor::d是描述子的维度，如果是D2Q9，那么这个Descriptor::d就等于2。所以j就是一个包含两个元素的数组。 第三句调用了一个函数，从函数名可以看到是得到rhoBar_j，看了代码以后，我知道这个东西是代表的是什么，但是我依旧不清楚这个有什么用。 假设采用的是D2Q9描述符，并且其离散速度如下图所示（Palabos里面的D2Q9的速度分布就是这样的）： 其中: 12345678910lineX_P1 = f[5] + f[6] + f[7];lineX_0 = f[0] + f[4] + f[8];lineX_M1 = f[1] + f[2] + f[3]; lineY_P1 = f[7] + f[8] + f[1];lineY_M1 = f[3] + f[4] + f[5];rhoBar = lineX_P1 + lineX_0 + lineX_M1;j[0] = (lineX_P1 - lineX_M1);j[1] = (lineY_P1 - lineY_M1); j就是这么个东西了，但是我还不知道它用来干啥的。 第四句，也就是最核心的部分，就是执行碰撞了。可以看到，他这里调用dynamicsTemplates类下的bgk_ma2_collision方法。 bgk_ma2_collision碰撞代码如下: 12345static T ‪bgk_ma2_collision(‪Cell& cell, T rhoBar, ‪Array const& j, T omega) { return ‪dynamicsTemplatesImpl ‪::bgk_ma2_collision(cell.‪getRawPopulations(), rhoBar, j, omega); } 其调用了dynamicsTemplatesImpl类下面的bgk_ma2_collision。而这个函数具体为： 12345678910static T ‪bgk_ma2_collision(‪Array& f, T rhoBar, ‪Array const& j, T omega) { T invRho = Descriptor::invRho(rhoBar); const T jSqr = ‪VectorTemplateImpl::normSqr(j); for (‪plint iPop=0; iPop < Descriptor::q; ++iPop) { f[iPop] *= (T)1-omega; f[iPop] += omega * ‪dynamicsTemplatesImpl::bgk_ma2_equilibrium ( iPop, rhoBar, invRho, j, jSqr ); } return jSqr*invRho*invRho; } 第一句定义了一个invRho，查了一下文档，发现其是一个这样的东西： 123static T ‪invRho(T ‪rhoBar) { return (T)1 / (‪rhoBar + (T)1); } 后面的可以看出来，也不宜过于深究了。其碰撞公式就是： $f_{k}(x+\\Delta x, t+\\Delta t)=f_{k}(x, t)[1-\\omega]+\\omega f_{k}^{\\mathrm{eq}}(x, t)$ 绕的有点多了。 4 数据处理器我认为这个部分是比较复杂的，原因是我在看后面的边界条件的时候，根据不同的边界条件大量的应用了数据处理器。单看用户文档还是无法完全了解。目前先按照用户文档的内容记录。 以下主要来自文档翻译。 数据处理器作用在整个求解域，或者是某个块（block）。在block-lattice中，他们用来实现所有无法通过动态类（Dynamic)实现的数据处理操作。这些操作主要是那些非局部操作，比如用于实现边界条件的有限差分模板的评估。在标量场和张量场中，数据处理器提供了在空间扩展域上执行操作的唯一（足够有效且可并行化）的方式。 此外，数据处理器能够在几个相同类型或不同类型的块之间交换信息（例如：块格和标量场之间的耦合）。这通常用于实现物理耦合（多组分流体，具有Boussinesq近似的热流体），初始条件的设置（从矢量场中的值初始化速度），或执行经典基于数组的操作（以元素方式添加两个标量字段）。 最后，数据处理器用于在整个块或子域上执行缩减操作。示例的范围从计算平均动能到计算作用在障碍物上的阻力。 数据处理器的定义和应用采用了两种不同的观点。在应用程序级别，用户指定给定块的区域（可以是矩形或不规则的），在该区域上执行数据处理器。如果块内部具有多块结构，则数据处理器被细分为几个更具体的数据处理器，各自负责atomic-block的数据处理。因此，在执行级别，数据处理器总是作用于atomic-block，即作用于先前通过将原始区域与原子块的域相交来确定的区域。 最后，定义新的数据处理器非常容易。您需要做的就是编写一个函数，该函数接收atomic-block和sub-domain的坐标作为参数，并在该子域上执行算法。所有复杂的操作，例如存在多块的操作的细分，或代码的并行化，都是自动的。 目前看起来比较头大，有很多东西现阶段不是很理解。不过好在用户文档里面也提到了：Palabos通过所谓的数据处理功能提供简化的界面，隐藏技术细节并让您专注于基本部分。也就是说知道怎么用就行了。看看，可能传递的就是一个atomi-block和一个sub-domain的坐标。然后指定一些palabos已经替我们处理好的算法。 文档提到，可以在文件\\src\\dataProcessors\\ latticeInitializerXD.h和.hh中找到更多关于块格的数据处理器的定义，并且在文件\\src\\dataProcessors\\dataFieldInitializerXD中定义作用于标量或张量字段的数据处理器。减少操作的评估示例在文件\\src\\dataProcessors\\dataAnalysisXD.h和.hh中提供。 实际文档中给出的地址路径不对，且latticeInitializerXD查找不到。究其原因，就是因为palabos官方的文档是1.1的，而我下下来的代码是2.0的。 因此我才用doxygen生成了2.0的开发文档。不得不说用起来非常的方便，查找功能很好。再次安利Palabos的2.0版开发文档，如果能对研究Palabos的伙伴产生作用，那是再好不过了。 5 吐个槽暂时写到这里，有点晚了，本来以为一两个小时可以搞定，没想到从下午写到了晚上。主要就是在研究collide函数花了比较多的时间。 如果只是想要初步的了解，不建议挖的过深。 我就是有时候挖到底层了，让后让自己迷失在代码里，抓不住重点。这是阅读代码所不应该的地方。 以后还是要注意一下，避免陷入代码海洋，而只见树木不见森林。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"Palabos","slug":"Palabos","permalink":"hxblog.top/tags/Palabos/"}]},{"title":"Palabos代码文档V2.0","slug":"Palabos代码文档V2-0","date":"2019-05-12T01:07:24.000Z","updated":"2019-05-14T13:10:01.383Z","comments":true,"path":"post/7d334df7.html","link":"","permalink":"hxblog.top/post/7d334df7.html","excerpt":"分享一个Palabos2.0版本的开发文档，用Doxygen生成。5.13更新：之前的版本没有搜索框，这次增加了带搜索框的；5.14更新：把开发文档上传至虚拟主机里面，可供所有人使用","text":"分享一个Palabos2.0版本的开发文档，用Doxygen生成。5.13更新：之前的版本没有搜索框，这次增加了带搜索框的；5.14更新：把开发文档上传至虚拟主机里面，可供所有人使用 1 简介官网上是1.1版本的。我这个虽然没有官网的好，因为只是用doxygen默认设置生成的。但是是最新的。 我看了下，2.0版本的代码注释量增加了很多。 生成的代码文档相应的阅读性更好些。 Doxygen的下载和使用方法参考上一篇博文。 示意图 示意图2 2 下载地址百度网盘：2333 更新了：推荐采用两个带搜索框的。 E55qfS.png 3 网络访问地址因为在不同的电脑看要重新下，非常麻烦，所以上传到了虚拟主机上。为了搞这个东西，特意买了一个便宜的虚拟主机存放，看来效果很好。 访问地址：http://palabos.asce.top 可惜的是我在用Doxygen生成代码的时候，没有把项目名改了，所以用的是My project。实在不愿意重新再生成一份然后上传了。 生成一个要一个小时左右吧，上传到服务器需要三个小时左右。 非常麻烦，所以就在主页把My Project手工替换成了Palabos V2.0。。。 不知道这样会不会侵权，在首页我对版权进行了说明，如果这个行为有侵权的可能，希望能联系我，我会立即删除网站。 联系方式： Email: lepas222@hotmail.com document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"Palabos","slug":"Palabos","permalink":"hxblog.top/tags/Palabos/"}]},{"title":"Doxygen+Graphviz自动生成代码文档","slug":"Doxygen-Graphviz自动生成代码文档","date":"2019-05-12T01:06:24.000Z","updated":"2019-05-14T07:34:00.592Z","comments":true,"path":"post/186025a3.html","link":"","permalink":"hxblog.top/post/186025a3.html","excerpt":"最近看Palabos的代码时，发现官网的Developer’s Guide居然还在1.1版。于是生成了一个2.0版的代码文档。一些事情记录于本文。 更新：5.14 增加搜索框","text":"最近看Palabos的代码时，发现官网的Developer’s Guide居然还在1.1版。于是生成了一个2.0版的代码文档。一些事情记录于本文。 更新：5.14 增加搜索框 为了方便分类，生成的Palabos代码文档的下载见下一篇博文。 1 Doxygen和Graphviz简介Doxygen：Doxygen是一个自动代码文档生成的软件，如果代码的注释写的足够好的话，可以生成一个非常不错的代码文档。作为阅读代码的辅助工具甚好。 Graphviz：Graphviz是一个开源的图形可视化软件。这里负责辅助Doxygen生成代码关系图。比如类的继承图，如下图所示。 类的继承图 2 如何使用 参考 Developer_Kale的博文 注意： Doxygen的GUI运行程序是Doxywizard 除了图中设置外，大部分默认就行 别忘了指定Graphviz运行目录 完了可以save一下，这样配置项能得以保存 3 如何生成搜索框（5.14更新）如图所示，采用保护导航栏的，可以正常生成搜索框： 设置 没有导航栏和搜索 有导航栏和搜索框 4 下载链接提供Doxygen和Graphviz的下载链接： 百度网盘： 2333蓝奏云：2333 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"好物推荐","slug":"好物推荐","permalink":"hxblog.top/categories/好物推荐/"}],"tags":[{"name":"Doxygen","slug":"Doxygen","permalink":"hxblog.top/tags/Doxygen/"},{"name":"Graphviz","slug":"Graphviz","permalink":"hxblog.top/tags/Graphviz/"}]},{"title":"TG开启本地代理的方法","slug":"TG开启本地代理的方法","date":"2019-05-10T03:05:20.000Z","updated":"2019-05-21T12:10:19.622Z","comments":true,"path":"post/d9455392.html","link":"","permalink":"hxblog.top/post/d9455392.html","excerpt":"TG开启本地代理的方法。","text":"TG开启本地代理的方法。 如果ss不开启全局的话貌似不能用。 所以可以在TG中开启本地代理 socks5： 地址：localhost端口：ss的本地端口/代理端口 设置如图： 本地代理设置 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"网络工具","slug":"网络工具","permalink":"hxblog.top/categories/网络工具/"}],"tags":[{"name":"Telegram","slug":"Telegram","permalink":"hxblog.top/tags/Telegram/"},{"name":"代理","slug":"代理","permalink":"hxblog.top/tags/代理/"}]},{"title":"学习笔记：Palabos（2）快速编程","slug":"学习笔记：Palabos（2）快速编程","date":"2019-05-08T11:49:34.000Z","updated":"2019-05-08T12:13:02.530Z","comments":true,"path":"post/52a5903c.html","link":"","permalink":"hxblog.top/post/52a5903c.html","excerpt":"本文内容对应官网文档。 主要内容是： 基本类型； 内存管理； 数组类型； 速度和密度； 并行化； 非侵入式编程。","text":"本文内容对应官网文档。 主要内容是： 基本类型； 内存管理； 数组类型； 速度和密度； 并行化； 非侵入式编程。 1 基本数据类型考虑到兼容性问题，有符号和无符号整数数据类型int和unsigned int被plint和pluint系统地替换。 考虑到并行性的问题，采用缓冲区pcout来替换cout作为输出。 2 内存管理Palabos采用的内存管理机制是这样的。简单来说，就是谁用谁管。当你把一个指针作为函数变量给函数的时候，你不需要考虑删除指针这件事。你甚至不能对其再做任何处理，因为这个时候，这个指针是函数在用。 相反，当你获得从一个函数返回的指针时，你需要对这个指针进行负责，内存释放也由你来处理。 文档中这样说道：关于谁删除许多实例指向的对象的问题通常通过每个对象的一个指针方法在Palabos中避免。也就是说，每个对象只有一个指针。每当第二个实例需要访问之前的对象时，采用的是克隆，而不是直接把指针指向之前的对象。比如： 12A* object1 = new A;A* object2 = object1->clone(); 因此，每个类都会要有一个克隆的方法需要实现。克隆方法都采用相同的形式： 123A* A::clone() const { return new A(*this);} 所以，当你创建或者继承一个类的时候，需要实现这个克隆的方法。我想这也应该是针对一些BlockXD或者Dynamic这种类型的类吧。 3 数组数据类型大型的数据，比如格子数据采用BlockLattice这种类型，这是palabos里面的专门的数据类型，具有很好的并行性。 1234567// Instantiate a nx*ny*nz D3Q19 lattice with double-precision// floating point numbers.MultiBlockLattice lattice(nx,ny,nz);// Instantiate a nx*ny*nz matrix of double-precision floating// point scalars.MultiScalarField field(nx,ny,nz); 第一个代码的作用是对多块网格对象（MultiBlockLattice）的实例化。采用双精度，D3Q19描述子的模板化实例。第二个是多标量场（MultiScalarField）的实例化。 较小型的数据采用C++的标准模板库中的容器来创建。比如向量：vector或者array： 12345plint numspecies = 5;// Instantiate a vector of double-precision floating point// numbers with 5 elements.vector viscosities(numSpecies);viscosities[3] = 0.63; 定义了一个长度为5的向量，对第四个赋值为0.63。 对于固定大小的数据，还可以采用数组：array： 12345// Instantiate a fixed-size array of type double and with// 3 elements. The values can be initialized directly in// the constructor for arrays of size 2 and 3.Array velocity(0., 0., 0.5);velocity[0] = 0.1; 定义了一个速度向量，然后对速度向量中的第一个分量赋值为0.1。 4 速度和密度文档中讲的比较清楚，以下为简单翻译结果。 在palabos里面很少采用rho和u这样的变量，通常采用rhoBar和j来代替。变量j是一阶速度矩，对于大多数模型，它与流体动量相同：j = rho * u。另一方面，变量rhoBar的定义可以定制。 默认情况下，它定义为rhoBar = rho-1，用于提高方法的数值精度。实际上，由于密度通常接近于1，因此通过表示在0而不是1附近波动的数量，您可以获得浮点变量表示中的有效数字。 在不详细介绍的情况下，这里有一些在rho / u和rhoBar / j表示之间切换的规则： 1234567891011121314151617// Use custom definitions in lattice descriptor to compute rho from rhoBarrho = Descriptor::fullRho(rhoBar);// Use custom definitions in lattice descriptor to compute rhoBar from rhorhoBar = Descriptor::rhoBar(rho);// Momentum is equal to density times velocity (component-wise)j[iD] = rho * u[iD];// Velocity is equal to inverse-density times momentum (component-wise)u[iD] = 1./rho * j[iD];// Inverse-density can be computed right away from rhoBar. Depending on// the custom definitions in the descriptor, this is substantially more// efficient than computing 1./rho, because the Taylor expansion of the// inverse-function is truncated at an appropriate position.u[iD] = Descriptor::invRho(rhoBar) * j[iD]; 简单的理解，就是好对于这些类，其都定义了一个转换方法，用于实现这两个物理量的转换。但是在实际的应用中，很显然采用rhobar的精度会高一些，同时用j代替速度u会显得更简洁。考虑到是精度和便携性。 5 并行化Palabos的分布式对象（MultiBlockLattice，MultiScalarField和MultiTensorField）是并行化的，也就是针对特定的对象并行才能实施。关于这一块后续再补充。 6 非侵入式编程6.1 关于编程的一些提醒 不要直接修改palabos的核心代码 采用拓展或者继承的方式来实现新的模型和方法 比如要实现一个与BGK类似的模型，则不应该直接修改src / basicDynamics / isothermalDynamics.h和.hh，而是应该新建两个文件：myNewModel.h和myNewModel.hh，其中包含一个继承自IsoThermalBulkDynamics的类MyNewDynamics，并定义与BGKdynamics相同的三种方法：clone（），collide（）和computeEquilibrium（）。这两个文件可以存放在任意目录。只需要确保在编译的时候能找到他。 这个应该大部分都是这样。 6.2 可拓展的部分在palabos中，可以拓展的部分包含： 编写新的动态类 编写新的数据处理器 编写新的晶格描述符 动态类用于定义新的局部碰撞步骤，而新的晶格描述符意味着新的晶格拓扑（离散速度，权重等），数据处理器用于其他所有事物。 暂时这么多，基本上是消化官方文档。 下一节继续Palabos的基本数据结构。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"Plababos","slug":"Plababos","permalink":"hxblog.top/tags/Plababos/"}]},{"title":"学习笔记：Palabos（1）格子离散化和动态行为","slug":"学习笔记：Palabos（1）格子离散化和动态行为","date":"2019-04-21T03:23:29.000Z","updated":"2019-05-09T12:46:44.539Z","comments":true,"path":"post/7ad67490.html","link":"","permalink":"hxblog.top/post/7ad67490.html","excerpt":"决定用Palabos来做了。开始记录一些关于Palabos的笔记。一边学一边记笔记，算是来自于官网的搬运和翻译吧。 知识点： dynamics objects，block-lattice 5.9日更新，修正了一些错误。","text":"决定用Palabos来做了。开始记录一些关于Palabos的笔记。一边学一边记笔记，算是来自于官网的搬运和翻译吧。 知识点： dynamics objects，block-lattice 5.9日更新，修正了一些错误。 1 离散化：构造格子网格我们通常需要构造一个格子块。而这个格子块通常就是求解域，可以理解成一个这样的东西： blocklattice.png 我们知道求解域分为好几种，最简单的就是矩形求解域，就像上图表示的这种。 上图是一个二维的例子。其实对应于具体的类就是BlockLattice2D。BlockLattice2D是一个类模板。Palabos和openfoam一样，大量采用了泛型编程。虽然目前还是刚刚看，不是很了解，但是这个东西应该非常重要。而且看官网的文档，这个类里面包括了非常多的虚函数，应该是不能直接用的东西。于是，要看看是在什么时候对这些类方法进行实现。 但是，如果边界比较复杂，或者局部需要加密的网格，就会用到多块的网格。这里就会用到MultiBlockLattice。 实际上，拿2D的举例，块（block）的继承关系如下图： block2D的继承图 可以看到，块分为三种大的类型： AtomicBlock2； MultiBlock2D； MultiGrid2D。 1.1 AtomicBlock2DAtomicBlock2D应该是最为普通的一种，而前面提到的BlockLattice2D就是继承于它。构造的是一个矩形区域的格子块，其构造函数如下： 12AtomicBlock2D (plint nx_, plint ny_)AtomicBlock2D (AtomicBlock2D const &rhs) 可以看到，其参数主要就是nx和ny。后面那个构造函数是复制构造函数。继承自AtomicBlock2D的，为构造格子块的类是BlockLattice2D。其构造函数是： 12345template class Descriptor>plb::BlockLattice2D< T, Descriptor >::BlockLattice2D ( plint nx_,plint ny_,Dynamics< T, Descriptor > * backgroundDynamics_ ) nx，ny表达了它继承自简单矩形块的构造方法，此外还多了一个参数，非常重要的参数，那就是Dynamics。Dynamics是动力学构造，在下一节介绍。 1.2 MultiBlock2D看名字就可以看出来，MultiBlock2D体现在多块网格上。用在格子构造上的是其子类：MultiBlockLattice2D 官方声明： 123template class Descriptor>class plb::MultiBlockLattice2D< T, Descriptor >A complex LatticeBase, itself decomposed into smaller components. 其描述如下： A complex LatticeBase, itself decomposed into smaller components. This extensible class can be used for example for cache-optimized lattices, irregular domains (no memory allocation in areas exterior to the domain) and parallel lattices. The actual behavior of the lattice is parametrizable by a multiBlockHandler instance, which is given to the constructor. The MultiBlockLattice does not itself possess LatticeProcessors. The Lattice- Processors are delegated to the respective LatticeBases. 翻译（凑合看看）： MultiBlockLattice2D是一种复杂的格子块，它可以分解成更小的组件。 这个可扩展类可用于缓存优化的格子、不规则域(在域外部没有内存分配)和并行网格。网格的实际行为可以通过一个multiBlockHandler实例参数化，该实例被提供给构造函数。 多块格子本身并不拥有格子处理器。这些格子处理器被委托给各自的基础格子。也就是多块格子它们格子有自己的格子处理器。 来看看其构造函数： 1234567template class Descriptor>plb::MultiBlockLattice2D< T, Descriptor >::MultiBlockLattice2D ( MultiBlockManagement2D const & multiBlockManagement_, BlockCommunicator2D * blockCommunicator_, CombinedStatistics * combinedStatistics_, MultiCellAccess2D< T, Descriptor > * multiCellAccess_, Dynamics< T, Descriptor > * backgroundDynamics_ ) 这里面包含的参数较多。但是可以看到MultiBlockManagement2D应该是管理多块网格的一个总的联系。BlockCommunicator2D 应该处理的是多块网格之间的数据传递，CombinedStatistics 是一个合并统计，需要进一步了解。MultiCellAccess2D 暂时未知，Dynamics就是指的格子的动态行为了。 MultiBlockLattice2D还有一个构造函数如下：12345plb::MultiBlockLattice2D< T, Descriptor >::MultiBlockLattice2D ( plint nx,plint ny,Dynamics< T, Descriptor > * backgroundDynamics_ ) 这个函数实际是为了指定一个背景网格的动态行为。 在官方文档中提到过：When constructing a new block-lattice, you must decide what type of collision is going to be executed on each of its cells, by assigning them a dynamics object. To avoid bugs related to cells without dynamics objects, the constructor of a block-lattice assigns a default-alue for the dynamics to all cells, the so-called background dynamics. After this, the dynamics of each cell can be redefined in order to adjust the behavior of the cells locally. 也就是说， 构造格子时，需要为每个格子分配动态行为：dynamics object。为了防止出现bug，在构造格子时，指定了一个背景动态行为：background dynamics。完成了背景动态行为的指定后，可以对需要单独处理的格子指定其的动态行为。通过两种方法： 指定某个格子的动态行为：1lattice.get(0,0,0).getDynamics().setOmega(newOmega); 调用get(0,0,0)获得坐标为(0,0,0)的这个cell然后调用getDynamcs()获得这个cell的动态再调用setOmega(newOmega)来设定这个单元的动态的松弛因子。恩，很好。很长。 指定某个格子块的动态行为： 1234// Override background-dynamics to guarantee and independent per-cell// copy of the dynamics object.defineDynamics( lattice, lattice.getBoundingBox(), new BGKdynamics ); 同时，官方文档里也提到了，defineDynamics方法对不同的类有不同的实现。 1.3 MultiGrid2D它和MultiBlock2D应该是有着本质的区别。MultiBlock2D体现的是“多块”网格，而MultiGrid2D体现的是“多重”网格。 同样的，创建网格用的应该还是其子类MultiGridLattice2D。 官方的描述：Main class when dealing with grid refinement. 可见，是处理细化网格的主要类。这种细化网格和前面的多块网格有什么区别？ 看看它的构造函数： 123456789template class Descriptor>plb::MultiGridLattice2D< T, Descriptor >::MultiGridLattice2D ( MultiGridManagement2D management, std::vector< BlockCommunicator2D * > communicators_, std::vector< CombinedStatistics * > combinedStatistics_, Dynamics< T, Descriptor > * backgroundDynamics, plint behaviorLevel, FineGridInterfaceInstantiator< T, Descriptor > * fineGridInstantiator_, CoarseGridInterfaceInstantiator< T, Descriptor > * coarseGridInstantiator_ ) 和多块网格的构造函数有相似之处。MultiGrid2D的构造函数同样有一个管理器：MultiGridManagement2D，但是communicators_ 和combinedStatistics_ 都变成了向量。此外还多了一个 fineGridInstantiator_ 和coarseGridInstantiator_ 变量。从字面意思上看应该是精细网格界面实例化和粗糙网格界面实例化。其应用需要进一步看看实例。 但是可以肯定的是，对于精细网格，就是用的该类来处理。 2 动态行为（dynamics）显然，动态行为是和物理行为相关最为紧密的。对于如何执行碰撞有和边界条件的实施有着重要的意义。 Dynamics的继承关系图 上图就是dynamic类的继承关系图，可见还是相当复杂的。带红色框的是文档化和结构化的类，也就是用的最多的类。下面列出来，可能会用到的动态： BGKdynamics：最基本的BGK动态 ExternalForceDynamics：包含外力的BGK动态 GuoExternalForceSmagorinskyBGKdynamics：这个应该是郭照立老师的包含外阿里的BGK动态 MRTdynamics：多松弛动态，实际上这个多松弛用的并不多 MomentumExchangeBounceBack：是处理无滑移边界条件的一个非常流行的实施手段。 来看看最基本的BGKdynamics，其构造函数如下： 12template class Descriptor>plb::BGKdynamics< T, Descriptor >::BGKdynamics ( T omega_ ) 可见，里面就只需要设置一个参数，那就是松弛因子。而这个类里面也就只包含一个成员变量，就是这个松弛因子omega_。 在BGKdynamics里面，包含了，包括碰撞的实施方法：collide；执行包含宏观量的碰撞方法：collideExternal；计算平衡态分布函数的方法：| computeEquilibrium | 暂时写到这里。主要看了两大类型的类。涉及到定义格子的blocklattice和定义格子动态行为的dynamic。 下一次写初始化和边界条件。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"Palabos","slug":"Palabos","permalink":"hxblog.top/tags/Palabos/"}]},{"title":"好物分享：利用onedrive和OneIndex搭建分享网盘以及私人图床","slug":"好物分享：利用onedrive和OneIndex搭建分享网盘以及私人图床","date":"2019-04-15T09:45:51.000Z","updated":"2019-05-08T14:50:01.932Z","comments":true,"path":"post/6c13cd55.html","link":"","permalink":"hxblog.top/post/6c13cd55.html","excerpt":"Onedrive教育版的5T空间怎么用？利用oneindex搭建一个分享网盘吧。","text":"Onedrive教育版的5T空间怎么用？利用oneindex搭建一个分享网盘吧。 1 写在前面总所周知，我们申请的5T的教育版onedrive网盘，其实是一个子账户。也就是说管理员是可以完全查看，甚至删除你网盘里面的内容的。这也是子账户不安全的地方。 只不过一般管理员大佬事情多，没空去研究数量几千的子账户。所以只要常规使用，肯定是没问题的。这就决定了教育版的onedrive无法作为个人的私人网盘。那就只能拿来存放一些供大家分享的容器了。比如分享的软件，影视作品，音乐，图片，书籍等待。 所以再次强调：切勿在onedrive里面存放违法以及过于私人的物品。 下面就是搭建一个分享网盘的具体操作。 2 搭建分享网盘需要的准备 一个onedrive账号：可以是教育版5T空间的，也可以是自己的私人onedrive，只不过私人的一般只有5G空间，还是拿来做同步盘比较好。 一个虚拟主机：支持PHP5.6以上就行，至于VPS，个人认为有点浪费了，如果用其他的搭建工具，就得要VPS。可以用很多国外的免费主机空间，要求不高，100M的空间就可以搞定。 一个域名：可以是免费的二级域名，也可以是购买的顶级域名。不过我觉得拿个二级免费域名就可以了。因为只是挂一个网页前端而已。一般拿到一个免费的主机空间都会送一个二级域名。 oneindex虚拟主机安装包：可以去官网下载。 如果采用onedrive教育版5T+免费主机+免费二级域名，那么就可以零成本搭建一个分享网盘或者图床了。 图床 分享网盘 3 开始吧3.1 下载oneindex作为备用去官网里面下载最新版本的就可以了。在本文章的后面，把本文用到的软件全部都打包了，也可以用本文后面的链接，不过最好在官网下，理由就是官网能保证最新版。而我的链接只能保证在写文章的这个时刻是最新版。 3.2 获得一个免费的虚拟主机空间免费的主机空间有不少，这里推荐我自己用的2个免费的主机空间：profreehost和freewebhostingarea。不过这种免费的主机空间速度不是很稳定，可能三天两头就要被墙一下。用邮箱即可注册。实测第一个传输速度要比第二个快一些，但是注册流程的话第二个简单一些。 所以如果要免费的主机，还是推荐国内的一个主机厂商：三丰云。这个可以用他的免备案的二级域名。最关键的是他的虚拟主机是国内的，也就是网速很快。如果是想要弄个稳定的免费网站，还是在这里弄比较好。唯一的问题，就是需要用手机注册，并且申请免费虚拟主机的时候，需要绑定邮箱。这样基本上一个人就只能申请一个免费空间了。 其实只要支持PHP的空间就行了。这里我用的是profreehost的主机作为演示。下图第一张是我注册好了之后的里面包含了账号信息和送的二级域名。后面的图是ftp信息。其实需要的就是ftp信息。要用它来上传oneindex。 注册成功的信息 FTP信息 3.3 上传oneindex至虚拟主机通过FTP软件连接到你的虚拟主机，然后把压缩包传上去。然后再在主机面板里把压缩包解压。这样上传速度会快不少。不过如果你的虚拟主机不支持在线解压，那就只好在本地解压好了再上传了。无非就是速度慢一点。 上传oneindex 这里演示的主机不支持在线解压，所以还是老老实实上传。图片中的FTP软件是8uftp，挺好用的。会在文末一起打包。 3.4 安装oneindex如果上传好了，直接打开你的二级域名，会开始进入安装程序。安装之前会自检，如果自检成功的话就是如下的界面。 过程比较傻瓜，这里就不写了。如果不清楚，可以看oneindex的官网，里面有一个GIF看的很清楚。 算了搬运过来吧。 install 至于里面的设置项都很简单，不用再说。 4 下载链接包括了oneindex的压缩包，FPT软件。 百度网盘：2333 （不出意外，都是这个）蓝奏云：etk9 我搭建的分享网盘里面也可以下载哦，在软件分类目录里面找。 我的分享网盘 我搭建的公共图床，欢迎使用，亲测速度挺快的。但是重要图片和私人图片不要存哦。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"好物推荐","slug":"好物推荐","permalink":"hxblog.top/categories/好物推荐/"}],"tags":[{"name":"onedrive","slug":"onedrive","permalink":"hxblog.top/tags/onedrive/"},{"name":"oneindex","slug":"oneindex","permalink":"hxblog.top/tags/oneindex/"}]},{"title":"如何制定一份旅游攻略？","slug":"如何制定一份旅游攻略？","date":"2019-04-13T15:44:32.000Z","updated":"2019-05-10T02:00:27.968Z","comments":true,"path":"post/b160a63e.html","link":"","permalink":"hxblog.top/post/b160a63e.html","excerpt":"4.15 更新。。。 假期是不是快要来了，是不是又想出去浪了？？？ 奉上一份旅游攻略制作方法，总结一下经验和教训。并以此制定一份五一出行恩施游玩的攻略。","text":"4.15 更新。。。 假期是不是快要来了，是不是又想出去浪了？？？ 奉上一份旅游攻略制作方法，总结一下经验和教训。并以此制定一份五一出行恩施游玩的攻略。 其实很多事情都是可以按照一定的流程来做的，我觉得做旅游攻略这件事情也一样，具有很多通用的方法。来试试，把这个过程流程化一下。 5.9更新：新浪微博图床挂了，前来补图。。。 1 作攻略之前需要搞清楚的几个问题从大到小：先要确定一些大的方向，然后才能做细化的安排。 1.1 时间安排这个时间指的是大的时间，从什么时候出发，什么时候回来。 比如我这次的休息时间，就是4月29-5月2日。5月3日就要开始搬砖了。 1.2 预算很明显，不同的预算制定出来的方案是完全不同的。根据预算，选择合适的出行方式，居住环境，以及旅游路线。 私以为，先把预算定下来，后续根据预算去做攻略会比较好。 这次给定的预算是3000元。 不过总的攻略做完之后，做了个详细一点的估算，超了一些，大概在3500。还好，在可接受范围内。这个预算可以参考一般的跟团游。我看了下，跟团游的价格大概是在1000/人。加上一些其他的自费项目，估摸在3000左右，稍微控制一下。 敲黑板：确定预算可以参考跟团游的价格。 1.3 参与人员在很多时候都需要确定参与人员，不同数量的参与人员，对方案影响非常大。比如只有2人的情侣游，以及十几个人的小团游是两个不同的概念。 这次的参与人员就是暂定两人，就是我和小NY。 1.4 大体的目标旅游的目的有很多种，随时起意想了下，对旅游的大体的目标做了一个脑图，如下： 旅游的目的 上述分类只是临时起意想到的。但无非就是这三大类。看看是想去看看山水风景，体会民俗风情，还是去寻找美食。或者这三种皆有。 然后，需要做的就是针对这些目的，去寻找一个你想去的目的地。 这次定的大目的地就是恩施 因为恩施风景美啊，早就想去了。然后是恩施位于我和小NY所在地的中间，这样我们可以分别出发，在恩施集合。 上述四个问题想清楚了，就可以着手开始制定详细的攻略啦。可以对这四个问题列一个表。 项目 详情 时间安排 2019.4.29-2019.5.2 预算 3000-3500 参与人员 2人 目的地 恩施 2 第二步：定点第二步，就是要拟定必须要去的点。这个也是从大到小。 先确定，去恩施必玩景点在哪里，美食打卡地在哪里。 这个好办，直接上网查资料，上携程或者马蜂窝，把景点排行罗列出来，逐个看，进行挑选。 来自马蜂窝 2.1 定景点对于恩施来说，很明显，大峡谷是必须要去的。招牌景点，还是值得一去的。 然后是腾龙洞，理由是这是中国最大的溶洞，世界特级溶洞之一。 第三个就是女儿城，体验恩施土家民宿风情最好的地方。 还有就是土司城。以前看小说尘埃落定的时候，就对这个土司城有兴趣，如果能去看一看，自然是不错的。 这样下来，一共有四个景点是必须要去的，那就是大峡谷，腾龙洞，以及女儿城和土司城。然后再来细化必须要去的点，这也是主要在网上查。比如，大峡谷必去景点之类的。 再然后，是要解决旅游过程中的吃饭问题，这一点也可以去网上找找，但是仅作参考，或作为备选。查找的方法是：大峡谷，午餐，晚餐，或者：大峡谷附近美食。这只是方法，仅供参考。 敲黑板： 定景点可以参考马蜂窝的景点排名 通过知乎大概扫一扫，筛选出一些景点 结合观赏季节和交通情况进一步筛选，这个交通可以大概的先简单了解一下，切不可在此阶段过于纠缠细节。 2.2 定美食打卡点作为吃货来说，找吃的地方远比找玩的地方更有趣，也更值得期待。所以必须要针对几个重点逛的地点查一下需要打卡的美食地。 同样，可以在马蜂窝、大众点评等网站先看一看。然后单独在百度里搜索”恩施必吃美食“，”恩施+不可错过+美味“。总之这是个技术活，思考一下别人写攻略或者软文会提到的词，然后利用这些词去找最有用的帖子或文章。 看到大家的推荐和评分高的，不管三七二十一，先记录下来再说。之后在整理。比如我在word下面暂时存放的有用信息。 先收集信息，然后再整理 根据一系列的整理，获得了在恩施以下几个美食打卡点： 张关合渣 张关合渣是恩施的一个非常特别的美食。 张关合渣有好几个店： 火车站附近就有一个：金桂大道汽车客运中心站副楼1层 学院路有一个：学院路128号 航空路有一个：航空大道62号(近金三角文娱广场) 女儿城也有一个：马鞍山路54号女儿城第一排 土家大院 土家大院 腊猪蹄 图片来源于网络，侵删。 其实附近还有一家巴仁堂，也是非常有名气的。到时候可以随机应变的看看。 小饭围鸭血火锅 这家小店来自于大众点评，看评价知道当地人也是比较推崇的。其实很多不是声名在外，但是口味很好的店都可以在点评找到。虽然点评也有刷单的嫌疑，但至少还是值得参考的。 小饭围鸭血火锅 图片来自于大众点评的顾客评论，侵删 这是一家川味火锅店，据说根据谭鸭血火锅改良而来。作为在成都吃过很多火锅的人来说，这个地方权当作为一次换换口味的权宜之计。 值得注意的是，这家店在一个景区附近：凤凰山森林公园。因此也可以把这个景点作为备选打卡点。 潜江油焖大虾 这个在女儿城这边，如果小NY爱吃虾，就带她来这里。也是来自于网友推荐。 敲黑板： 美食寻找有三个方法：马蜂窝美食排名，大众点评口味最佳，度娘技术搜索 记录美食地一定要把详细地址写上，方便后面做路线攻略 3 看攻略，汲取前人经验确定了几个定点之后，就要去看攻略了。这些攻略能提供大量的经验，也可以让旅游的路线有个大致的想法。 但是攻略的查找非常有讲究。那些只喜欢拍美景说祖国大好河山的，各种美滋滋的，一般都没什么干货，没有太多的价值。我们就是 要看哪些吐槽的，那些别人踩过的坑。 推荐知乎，毕竟广告少，利益关联没那么明显。 第二个就是小红书。同样，里面有很多个人游记，这些参考价值很大，一定要区别软文和真正的个人写的帖子。 建议阅读不少于10份的攻略，并对每份攻略中提到的避坑事项，以及各种合理的推荐事项进行记录。 敲黑板： 重视那些吐槽的，和别人踩过的坑 区分软文和真实心得 4 为每个打卡点确定时间定时的方法很简单，看哪种跟团游的行程说明就可以了。比如携程上就对每个景点和时间的安排很详细，这些都可以作为参考。 这就是携程跟团游的时间 这样，可以确定下几个重点旅游地点的游玩时间： item Model 大峡谷之七星寨 4-6小时 大峡谷之云龙地缝 2小时 腾龙洞 3小时 女儿城 3小时 土司城 2-3小时 可以看到，基本大峡谷所需要的时间是最长的，所以大致可以确定时间上的安排了。大峡谷可以考虑选择2日游。 敲黑板： 通过携程等网站，找到跟团游来确定每个打卡点游玩的时间 5 穿插于每个打卡点——制定路线其实把攻略看完，心里也就有个底了。接下来就要开始完成攻略中最为重要的一步。也是衡量攻略准备工作做的到不到位的重要依据。那就是制定路线，把每个打卡点串起来。 同样的，遵循从大到小，从远道近的原则。 5.1 跨省路线这个路线一般都没有什么难度。只要确定好坐哪趟火车就行了。为了省钱+省时间，我决定坐前一晚上的卧铺，睡一晚第二天到目的地的方案，查了一下，时间正是刚刚好。而且，返程也是有刚刚好的车。 跨省路线 5.2 市外交通如果景点距离市区较远，则必须制定市区到景点的路线规划。 比如我们这次，需要长途的，都是一般在市外的。比如大峡谷（距离市区60Km）、腾龙洞（位于利川市）。 至于女儿城和土司城，都是在市区内，而且恩施市区不大，所以打的可以全部搞定。长途交通重点就是这两处的来回了。 以下是几个重要地点的路线： 恩施站——大峡谷 大峡谷——腾龙洞 恩施——腾龙洞 这里设定两个腾龙洞的路线，是因为现阶段不知道从哪里出发到腾龙洞是比较合适的。所以理论上两条路线都要查。而且这两条路的选择还会影响住宿的选择。 先看恩施站——大峡谷。 恩施到大峡谷可以直接做专线车。专线车直达景区。25元一人，1.5小时车程。滚动发车，间隔半小时。 恩施火车站出站口斜对面恩施汽车客运中心搭乘恩施—大峡谷的专线车，单程25元，车程1.5小时，客运电话：0718——8542036 恩施市区内的朋友可在微信小程序“呼我出行”上预定搭乘 恩施——大峡谷快捷专线车 联系电话：19971823693 专线车运营时间07：00——17:30（两地都是这个时间） 大峡谷——腾龙洞 并没有专线车，因为垮了两个市，但是可以包车，一般包车价格300元 然而包车价格略贵，如果四人同行，每个人就需要80元左右。 不推荐，性价比不高，且不一定安全。 腾龙洞肯定是直接回恩施了。回恩施只有先坐车到利川站，利川站坐火车去恩施站。 恩施——腾龙洞 恩施直接坐火车到利川，利川有公交车去腾龙洞，只是公交车不到腾龙洞，需要走很远的距离 利川火车站出站右侧每天8:10后有去腾龙洞的专线车，5元车票，也可车站滴滴专车约30元直到售票处。 如图，虽然大峡谷离腾龙洞不远，但是过去全是山路，而且有一段是连地图都看不到的路。 从大峡谷会到恩施，再去腾龙洞，可以好好休整一番，第二天早上从恩施出发，坐一段短途火车亦是一件快事。 5.3 市内短途交通对短途的交通，最好每个查一遍，即把需要打卡点之间的交通都查一查。看看是否有公交，是否好打的士。这样避免到时候遇见突发情况慌张不已。 这是我的市内打卡点： 市内打卡点 每一段的交通我都查过，从距离来看，每一段都可以打的，最远也就是10公里，约30元左右。但是有些时候，能省一点，且在不影响体验的情况下，能坐公交当然也不错。 恩施站-土司城 可以坐公交 观光专线，约50min。 女儿城——恩施站 步行都较长 可以看到，步行距离比较长，优先打的。 土司城——张关合渣学院路 步行太长，而且绕路，因此决定不去学院路这个店。 土司城——张关合渣航空路 这个刚刚好。所以张关合渣就到这家店来吃了。 张关合渣航空路——凤凰山森林公园南门 可以坐公交。 小饭围鸭血火锅离凤凰山森林公园非常近，直接走路就行。 小饭围-恩施站 十公里，步行不算太远，可以坐公交。坐过去就要各自回家了。 这样基本上确定一些事情了。至少市内交通该如何走应该很清楚了 从恩施站出发到女儿城，可以在女儿城玩到晚上再回去。吃一顿中午饭和一顿晚饭，也可以在那边吃小吃。 不去学院路的张关合渣，因为绕远了。 酒店就定在恩施站附近，因为去大峡谷和腾龙洞都要从这里出发，游完返回来也是到这里。 从酒店出发到土司城，逛完就可以坐公交车或者打的去吃张关合渣了。吃完张关合渣就可以坐车去凤凰山森林公园，坐到南门。 逛完凤凰山森林公园就可以去吃小饭围鸭血火锅。吃完就坐车回恩施站了 敲黑板： 定路线一定要从大到小 市内路线一定要查好，直接决定攻略的可行性 市内路线先找好打卡点，再查路线，每条路线都要查，确定最好的游玩路径 6 找好歇息点，完成攻略前面的工作做完了，就需结合路线和时间分配，确定最终的旅游路线图，并指定歇息的地方。 话说，出去旅游，图的就是一个放松，不要把自己搞得太累。之前和羊宝一起去峨眉山的时候，花2天爬上峨眉山，弄得全身狼狈，还犯了肠胃炎。虽然见过了大好河山，但是却受了不少苦，心情也没有多好。 其实回想起来还是挺自责的。毕竟没有留下更多的开心。所以希望在后面的旅游中，让我们开心快乐才是第一位。 不多说，希望以后在指定攻略的时候，能把行程安排的更加轻松一点，吃的住的都更好一点，不要把自己弄得太狼狈。 敲黑板： 行程不能安排的太满，保证游玩下来乐趣与放松并存 一个上午的游玩时间大概为2小时，一个下午的游玩时间在3小时左右 6.1 确定总体路线和时间分配首先是到恩施的时间。前面查过，都有晚上22点出发，第二天早上到恩施的火车。坐个卧铺睡一觉到恩施，这是最省时间的。 所以基本上先按照早上7：30到恩施来制定旅游计划。 考虑到能够轻松起见，把大峡谷拆分成2天来游玩。而且住在大峡谷，也可以多呼吸一下新鲜空气。 所以大体的安排就出来了。 第一天去恩施大峡谷，游玩七星寨；游玩回来休息一晚； 第二天睡到自然醒，多睡会。然后去云龙地缝，游玩之后回来就吃个午饭，准备回恩施。回到恩施基本上快到下午三点左右，先到酒店放下东西，洗个澡换身衣服，去女儿城。在女儿城逛一逛，吃点小吃，看看纪念品什么的，然后在女儿城吃晚饭。吃完晚饭再在女儿城逛逛，看看表演。晚上8点准备回住的地方。 第三天不能睡到自然醒，因为要去腾龙洞哇，因此早上7点半起床还是必要的。然后吃完早餐去坐车去利川，去腾龙洞游玩之后当天回来。歇息，有精力可以晚上去周边逛逛。 第四天晚上就要准备坐车回去了，所以不可能再去远的地方。所以早上睡到自然醒，然后去土司城。游玩土司城之后去吃午饭，吃完午饭当然选择去凤凰山森林公园了，因为那里有一个美食打卡地啊。 6.2 歇息的地方至于找酒店，这就没有什么技巧了，时间安排和路线都弄好了，找酒店就是上个携程艺龙的事情。 需要考虑的是： 交通是否方便 如果在景区住宿是否离景区近 是否卫生干净 是否在路边上，如果在路边上会比较吵 要做的就是：看地图，看评价，看价格。 这次确定下来的酒店： 大峡谷： 恩施大峡谷观景寨客栈——离景区近，可步行 恩施大峡谷许府庄园 ——环境好，离景区远，但是老板可以接送 恩施火车站： 尚一特精选酒店(恩施火车站店)：这个已经看了下是最好的了。这个酒店要提前订，快没房了。5-1人可不少。 备选：七天，速8，城市快捷 话说恩施住宿真不便宜，火车站这里稍微好点的，最便宜的都要200以上了，这可能和节假日有关系吧。 7 完备攻略的产生接下来，就是更为详细的攻略安排了，因为我们已经没有什么不能确定的了。 做完以下的工作，就可以得到一份完备的攻略。 7.1 详细日程Day1: 7:30在恩施火车站集合，然后去汽车客运站坐车准备去大峡谷。 到了大峡谷，大概是9：30左右（车程90min）。可以跟旅店联系一下，能否先办理入住，把东西放好。如果不行，那就只有背着行囊上路了。 游玩七星寨（4-6小时），显然要在旅途中吃一顿饭。据说旅途中供应点比较多，而且价格都还是比较实惠的。一碗粉也就10元钱。不过备点干粮肯定没错。以防低血糖。 游完下来，基本上是下午2点-3点左右，办理入住，洗个澡收拾一下自己。然后休息一下，准备吃晚饭。晚饭可以就在酒店吃。期间可以出去逛逛，呼吸新鲜空气。 当天晚上有演出，然而门票211，对此不是很感冒。 Day2: 睡到自然醒，但是最迟别超过8点，收拾一下吃早餐，最迟9点要到游客中心，买票游玩云龙地缝（2-3小时）。可以慢一点，多拍点照。 回来肯定饿了，吃个午饭，然后准备等车回恩施。 到恩施大概是2点到3点左右。入住恩施的酒店，放下行李物品，准备去女儿城。 游玩女儿城（2小时），开始吃晚饭。这里有一个美食打卡地：土家大院或者油焖大虾 吃完饭还可以在女儿城逛逛，喝点东西坐一坐。 得要买一点干粮备着，因为Day3去腾龙洞可没有吃的东西了。 然后早点回去，据说晚了既不好打的，又不好坐公交。 Day3： 早上可以睡到自然醒，赶10：19的那趟火车。7点31那趟车确实有点早，得6点半起床才行。看情况，早去就早回，晚去就晚回。按照后面的时间安排。 按照30分钟车程，算上等车的时间，到了景区基本上12点了。可以找个地方吃点干粮。然后赶路。这样到可以去看12:50的那场激光秀。看完激光秀继续往里走，走完回来再等着看下午4点20的那场歌舞演出。 看完演出大概5点钟。然后准备回恩施。可以打的去利川火车站。约30元。 Day4： 早上睡到自然醒（8点），吃完早餐然后坐公交去土司城（9点得出门）。此次出门，得带上行李了，要退房。 到土司城（10点），开始游玩（2-3小时） 游玩之后可以直接打个的去吃午饭，此时大概是在12：30。打卡地点：张关合渣。 吃完午饭可以估计会比较累，根据体力情况选择是否去凤凰城森林公园。可以公交，也可以打的。 游玩凤凰城森林公园。（2小时） 准备去吃晚饭，打卡地点：小饭围鸭血火锅 吃完火锅，就打的直接去火车站。 要分别了。。。 7.2 攻略补充这一部分，一般用于需要提前准备的东西： 学生证：这个神器需要提前准备好，动不动就是好几百的门票，两个人可以省下不少钱。 安全用品：创可贴，风油精等防虫 雨衣：景区天气多变 带伞：防止下雨 穿长裤，要带外套，换洗衣服（临近出发前几天关注天气预报，及时准备） 其他：自拍杆，翻晒用具，充电宝，帽子等 7.3 可以采购的特产（4.15更新） 山胡椒 枞树菌（马尾松） 关口葡萄（这个季节估计是没有） 腊肉和香肠 7.4 其余的特色小吃（4.15更新） 社饭，包谷饭，洋芋饭 六角亭－田烧饼 舞阳坝－物资局油香 舞阳坝实验小学门口的炸酱豆皮 鸭杂－汪营鸭杂(利川，离得很远，不考虑) 鮓广椒 油炸小土豆 卤鱼 － 辣得叫（恩施市学院路湖北民族学院上行100米玫瑰花园酒店对面巷子内，可以考虑） 女儿城的赵妹儿油香 这些小吃可以见缝插针的去找找。因为我们的行程规划的不是特别的紧。 至此，一篇完整的攻略就做完了，做攻略其实还是需要花费很多时间的。尤其是要做一份详细的攻略。 这份攻略我每天抽出2个小时，一共花了五天才完成。然而计划赶不上变化，后续还是会有很多问题，这就要考验临场能力了。记住宗旨：出来玩是放松的，一切以此为目标。当断则断，当舍弃则舍弃。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"生活","permalink":"hxblog.top/categories/生活/"}],"tags":[{"name":"旅游","slug":"旅游","permalink":"hxblog.top/tags/旅游/"},{"name":"攻略","slug":"攻略","permalink":"hxblog.top/tags/攻略/"}]},{"title":"好物推荐：我的百度网盘的解决方案","slug":"好物推荐：我的百度网盘的解决方案","date":"2019-04-07T15:04:09.000Z","updated":"2019-04-07T16:59:26.457Z","comments":true,"path":"post/3e7627e9.html","link":"","permalink":"hxblog.top/post/3e7627e9.html","excerpt":"百度网盘，如何高速下载和上传？ 主要是Windows下的解决方案。 方案提出日期：2019.4.7，后续的变化会在本帖更新。","text":"百度网盘，如何高速下载和上传？ 主要是Windows下的解决方案。 方案提出日期：2019.4.7，后续的变化会在本帖更新。 1 如何高速下载？能实现高速下载的软件目前来说还是挺多的，但是我认为目前最科学的解决方案有四个，针对不同的应用场景： pandownload speedpan BaiduPCS-Web IDM+脚本 前三个的官网地址都附在上面了，在官网地址都有下载地址。下面分别描述在不同的场景如何应对。 1.1 小文件下载首推：pandownload其次：IDM+脚本 为了解决你的选择综合征，那就直接选第一种就行了。原因有二： IDM+脚本的方式不稳定。脚本通常需要更新，而且IDM的调用也会随时出现抽风的情况。但是不得不说，IDM是下载工具里面最神奇的存在，没有之一。 Pandownload可以直接复制分享链接然后弹出界面直接下载，前提是你要在pandownload里面登录你自己的账号。 如下图： 分享链接下载 1.2 大文件下载首推：pandownload其次：speedpan再次：BaiduPCS-Web 原因在于： pandownload可以cookie登录。免去了要弄验证码的环节。关于如何使用cookie登录，官网的教程里面有，这里不再说。虽然说弄到登录的参数稍微复杂一点，但是一劳永逸啊，以后登录可以无视验证码。因此，就这一点它排在speedpan前面。而且颜值我觉得也比speedpan要高。 至于BaiduPCS-Go。虽然也可以利用cookie登录，但是不能下载分享链接。必须要保存到自己的网盘之后，在自己的网盘里下载。 总体来说，pandownload是我目前百度云下载的首选工具。 1.3 账号限速时怎么办？百度网盘目前通过账号限速的方式来控制非会员的下载量。也就是说，当你在一段时间的下载量超过一定阈值时，就会针对你这个账号进行限速，无论你用何种方式，依然是龟速。那么咋整？目前来说，我知道以下几个方法： 方法一：停用一段时间后再用，或者切换一个账号； 方法二：充会员，普通会员就行。普通会员就不会再账号限速了。 方法三：租用别人的VIP会员登录到自己的pandownload里面，然后下载分享链接。 方法四：购买speedpanX的高速下载包 一般来说，只要你不是一次性要下载几十个G的东西，都是够用了的，不存在账号限速。如果确实限速了的话，如果不是急着要下下来，等一等也是很好的。如果有几个百度网盘账号的话，退出来换另一个登录再下就可以了。 但是解决账号限速最靠谱的方法，还是要付点钱。方法二，方法三，方法四本质都是一样的，就是利用会员不限速的特性。充会员显然成本要高一点，官网十几块钱一个月。租会员我认为是性价比最高的，一般租个一年也就几十块，如果就那么几天要大量下载，租个几天也就几块钱。不过要担心的是，这种账号一般都是跟别人共享的，会存在顶号的风险。而且不是自己的号，要下载自己的东西也必须先分享出来才能下载。但确实是解决短时间账号限速的最佳方案。 至于购买speedpanX的高速下载包，其实和租会员是一个意思。只不过它利用的是软件内置的会员账号下而没有给你表现出来而已。并且高速下载包是按流量付费的，大概是5元钱50G的流量。本来想把图截下来的，但是无奈它的官网歇菜了，等好了的时候大家可以自己上去瞧瞧。我个人认为，租会员比这个划算，因为你租到会员之后，一直下载就行，不会限制你下载的流量，只是有时间限制。只不过租会员这个方法程序上会比直接买高速下载包麻烦一些。毕竟你直接扫码支付一个下载包就能用了。租会员你首先得找到能租的地方。 咳咳，这种神奇的交易当然只能存在于淘宝、闲鱼、微店、拼多多这种地方了。不过，搜索的方式要注意一点，你直接搜索“百度网盘会员”是出不来任何结果的。换成“du盘 SVIP”，“baidu VIP” 试试，你会发现新大陆。 注意，speedpan和speedpanX是两个软件，虽然是一个团队开发的，但是一个免费一个付费。 总的来说，我个人更倾向于，有计划下载文件。至于账号限速如何解决，花点小钱就OK了。至于说采取何种方法，就看自己吧。 2 如何高速上传文件？高速上传只有一个解决方案了，因为别的都不支持上传功能，那就是： BaiduPCS-Web 现在还是好好的来介绍一下这个东西吧。其实这个才是真正的神器。这个其实是把另一个神器BaiduPCS-Go给web化了。而BaiduPCS-Go是一个百度网盘的命令行工具。当然，对于非代码人员来说，命令行工具还是很不友好的 。于是有人就把这个命令行参数加了个Web UI。也就是这个BaiduPCS-Web。 使用方法：下载软件后直接双击 ，然后会打开网页： 登录界面 在这里登录就行了。其实你已经看到了，他可以支持BDUSS登录。 登录以后的界面是这样的，你可以下载，可以上传。实测上传速度有5M左右的上传速度（电信百兆宽带）。 上传情况 据测试，上传分两种情况： 秒传：当百度网盘里面存在同样的文件，即便文件再大，也几乎是秒传。你可以这样理解，在上传之前，先检查了上传的文件是不是网盘库里已有的文件，如果有，那就秒传，相当于把那个文件在你这里做了一个索引。 高速上传：也就是当网盘库里没有你要上传的文件，那就只能乖乖上传了，不过上传的的速度也是非常可观的。 据我测试，一天上传量超过50G以后依然能高速上传及秒传。也就是说，上传不存在账号限速。 3 聊一聊百度网盘大家说百度网盘不良心，针对普通用户限速的。其实是很没道理的。 如果自己弄过网站，或者了解过服务器的价格就知道，超级会员288一年5T存储空间+高速下载基本上算是没什么可以赚的，不亏钱就算不错了。大家可以去看看一台云服务器的价格，也可以看看别的网盘的价格。 阿里云的存储包 icloud 阿里云的存储器基本上是天价了。icloud2T每月68元，一年下来八百多了。国内115也要500一年。腾讯微云的体验就不说了，充过会员，体验极差。比不上充了会员的百度云。 其实这样看下来，百度网盘才是真正的是良心网盘。 因此，如果不缺钱的话，还是冲个会员吧，高速传输+5T容量+一大堆的人性化服务（比如批量转存上限、在线解压等）真的很香。 如果你确实没有钱购买会员，我个人建议你，在力所能及的范围内多申请几个2T的网盘。为什么？ 你也许会问，网盘要那么大空间干嘛？搞那么多个账号难得管理。为什么呢？ 逻辑很简单。 第一，你看看一个2T的移动硬盘要多少钱，如果你多一个账号，意味着可以免费多那么多的存储空间。而且可以在账号限速的时候有备用盘用。第二，网盘要那么大空间干嘛，存的了那么多东西吗？这其实是一个伪命题，尤其是在5G即将商业化的时候。 当传输速度增长到一定水平，你就不会再说这样的话了。 如果传输速度能达到5G的水平，基本上网盘和移动硬盘的体验没有任何区别。达到5G的传输速度，人们对存储的要求又将大不一样。 第三，我认为文件放在百度网盘里，依然是可靠性非常高的。也许会担心，百度网盘垮了怎么办？我认为，百度网盘垮的可能性相当小。而且，退一步讲，即便他要倒了，也会有缓冲的时间让我们把数据安全的down下来。就像360网盘倒了的时候一样。不过我认为，百度网盘跨这种情况几乎不可能出现，最多是把价格提上去，即便提上去，也比自己买硬盘自己保存更方便和更划算。 所以啊，珍惜这个可以随便就弄到2T的云存储的机会吧，珍惜这个有这么多好用的破解限速的软件存在的当下吧。 4 下载链接这里提供pandownload，speedpan，以及BaiduPCS-Web的文件。 其实官网都能下得到。建议大家直接在官网下载（speedpan的官网崩了）。因为随着时间的推移，这里的软件版本可能不是最新版。 蓝奏：：d6w8百度网盘：2333Onedrive 很晚了，欧亚斯密，米娜桑。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"好物推荐","slug":"好物推荐","permalink":"hxblog.top/categories/好物推荐/"}],"tags":[{"name":"WPC","slug":"WPC","permalink":"hxblog.top/tags/WPC/"},{"name":"百度网盘","slug":"百度网盘","permalink":"hxblog.top/tags/百度网盘/"}]},{"title":"容易的生活，被替代的命运","slug":"容易的生活，被替代的命运","date":"2019-04-06T14:15:12.000Z","updated":"2019-04-06T15:50:21.572Z","comments":true,"path":"post/82140801.html","link":"","permalink":"hxblog.top/post/82140801.html","excerpt":"这是一篇鸡汤文。不喜误入。","text":"这是一篇鸡汤文。不喜误入。 写这篇文章的缘由，是因为看到一个两分多钟的动画电影。 虽然这个视频很早以前已经看过，然而时隔许久，再次看到依然让人背如芒刺。 生活从来都是不容易的。容易的生活，都是容易被人替代的。 如果自己不努力，这个位置会有更多的人来取代你。 让人震撼的是，自己一直以为很苦逼的生活，殊不知却是别人眼里的肉。而不停的让自己放松，随性而活，一直待在自己舒服的区域，会让人丧失掉作为人进行生存的竞争本能。 忘了从什么时候开始，我越来越喜欢安逸了。 这可能和年龄的增长有关。不过我也知道这是个借口。 今天下我和苟哥的同学帮苟哥搬宿舍。他到新博士公寓了。在晚上吃饭的时候听他的同学聊到，他们实验室有多变态。 每天要打6次卡，早上一次，中午午餐来回两次，晚餐来回两次，晚上11点半下班一次。 原来定在12点半，之所以定在晚上11点半是因为12点半已经属于第二天了。 而他每天晚上工作到两点半。不为别的，是为了补以前拉下来的东西。他和我一样，在博士的前几年做了太多的工程项目。然而他面对困境的方式，却比我强了太多。 想起自己现在的生活真的是闲适得不得了。 虽然加班到两点半我依旧认为对于我来说没啥可操作性。 但是却足以说明一些事情。 那就是当你在慢悠悠的往前走时，有很多人却在不停地向前。被远远甩开而不自知，直到连背影都看不到了才想起这个人曾经和自己在同一条起跑线上。 生活不易，记住，生活从来都是不容易的。容易的生活，意味着被取代。 或被人，或被机器所取代。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"生活","permalink":"hxblog.top/categories/生活/"}],"tags":[{"name":"容易的生活","slug":"容易的生活","permalink":"hxblog.top/tags/容易的生活/"}]},{"title":"好物推荐：小黄条————一只简洁小便签[WPC-工具]","slug":"好物推荐：小黄条————一只简洁小便签-WPC-工具","date":"2019-04-06T06:57:27.000Z","updated":"2019-04-06T07:22:37.237Z","comments":true,"path":"post/5ffa4e34.html","link":"","permalink":"hxblog.top/post/5ffa4e34.html","excerpt":"终于找到一款在移动端和PC端都满意的桌面便签软件了！","text":"终于找到一款在移动端和PC端都满意的桌面便签软件了！ 1 介绍小黄条桌面便签 官网有比较好说明，这里将一些重点特性摘抄如下，可见一斑： 无推送、无广告、无红点，不主动打扰 任务记录云端存储永不丢失 任务支持简单排序，可对重要的任务设置“置顶” 跨平台同步，覆盖所有办公场景，随时随地查看、记录、编辑、管理任务 已完成的任务按天归档，方便快速回顾本周主要工作，高效输出工作周报 windows版本支持嵌入桌面，搭配【极简】模式完美融入系统桌面 windows版本支持窗体移动到屏幕边缘时自动隐藏，便于保护隐私 windows版本支持自定义字体、字号、间距、文字颜色 windows版本支持使用快捷键快速隐藏/显示主界面 App可对每个任务单独设置提醒 跨平台： Windows Android IOS 不支持Mac 关于图片就贴两张官网的图片，适合懒得新开网页的懒人 它在win下是这样的 设置 2 下载地址官网有下载地址，这里把最新版的搬运过来了。好工具做个备份总是没错。内有安装版和绿色版以及安卓版。 蓝奏：密码:9lst 百度网盘 ：密码：2333 注： 本网站所有的百度云提取码均为2333 一木禾网盘不支持文件夹分享，以后只提供蓝奏和百度网盘的下载链接 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"好物推荐","slug":"好物推荐","permalink":"hxblog.top/categories/好物推荐/"}],"tags":[{"name":"WPC","slug":"WPC","permalink":"hxblog.top/tags/WPC/"},{"name":"桌面便签","slug":"桌面便签","permalink":"hxblog.top/tags/桌面便签/"},{"name":"小工具","slug":"小工具","permalink":"hxblog.top/tags/小工具/"}]},{"title":"好物推荐：证照之星[WPC-工具]","slug":"好物推荐：证照之星-WPC-工具","date":"2019-04-03T07:01:19.000Z","updated":"2019-04-03T10:23:50.100Z","comments":true,"path":"post/63a9fbcd.html","link":"","permalink":"hxblog.top/post/63a9fbcd.html","excerpt":"最近帮着老姐处理一张证件照，把证件照的背景换成白色，衣服换成深色，在网上找了找不少的工具，美图秀秀，还有一些在线的处理网页什么的。最终最好用的就是这个——证照之星。因为它简单，而且效果很好，关键是免费，没有广告。","text":"最近帮着老姐处理一张证件照，把证件照的背景换成白色，衣服换成深色，在网上找了找不少的工具，美图秀秀，还有一些在线的处理网页什么的。最终最好用的就是这个——证照之星。因为它简单，而且效果很好，关键是免费，没有广告。 对于PS技术可以忽略不计的人来说，找个好用的小工具是最好的。 关于找工具这种事，我一向都比较上心，为的就是一劳永逸。这次找好了，以后处理这种事就会效率大增。没想到这一找就是三个小时。。。 1 界面废话不多说，先给个正脸： 证照之星界面 这里的证件照是百度直接找的，侵删。。。 2 背景抠图很简单，只需要一分钟不到就可以完成。 背景抠图 3 细节处理对于抠图出来的只是个粗略的轮廓，后面用精细橡皮擦再处理一下就完美了。 细节橡皮擦 4 其他功能软件还有很多其他的实用功能，比如换装，比如调整肩膀高度什么的。 其他功能 5 下载链接蓝奏 一禾木网盘 百度网盘：u6yf 【 申明：资料来源于网络，侵删】 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"好物推荐","slug":"好物推荐","permalink":"hxblog.top/categories/好物推荐/"}],"tags":[{"name":"WPC","slug":"WPC","permalink":"hxblog.top/tags/WPC/"},{"name":"工具","slug":"工具","permalink":"hxblog.top/tags/工具/"},{"name":"证件照","slug":"证件照","permalink":"hxblog.top/tags/证件照/"}]},{"title":"matlab：LBMD2Q9的迁移","slug":"matlab：LBMD2Q9的迁移","date":"2019-03-30T15:52:06.000Z","updated":"2019-03-31T02:32:02.729Z","comments":true,"path":"post/98b0c1dd.html","link":"","permalink":"hxblog.top/post/98b0c1dd.html","excerpt":"LBM的迁移，实际上就是数组元素的平移。","text":"LBM的迁移，实际上就是数组元素的平移。 做迁移的时候，最需要注意的就是数值覆盖。所以用C来实现的时候，替代的顺序和传递的顺序应该是相反的。D2Q9的离散格式如下： D2Q9 f1(i+1)=f(i)f3(i)=f3(i+1)以此类推。 一种C形式的迁移用for循环语句： 123456789101112131415161718192021222324252627282930313233#f1,f3for j=1:m for i=n:-1:2 f(i,j,1)=f(i-1,j,1); end for i=1:(n-1) f(i,j,3)=f(i+1,j,3); endend#f2,f5,f6for j=m:-1:2 for i=1:n f(i,j,2)=f(i,j-1,2); end for i=n:-1:2 f(i,j,5)=f(i-1,j-1,5); end for i=1:(n-1) f(i,j,6)=f(i+1,j-1,6); endend#f4,f7,f8for j=1:(m-1) for i=1:n f(i,j,4)=f(i,j+1,4); end for i=1:(n-1) f(i,j,7)=f(i+1,j+1,7); end for i=n:-1:2 f(i,j,8)=f(i-1,j+1,8); endend 这种方式的代码可以很方便的改成C语言。 2 数组操作型在MATLAB里面实现这个还有更简洁的方式： 12345678f(2:n,:,1)=f(1:n-1,:,1);f(:,2:m,2)=f(:,1:m-1,2);f(1:n-1,:,3)=f(2:n,:,3);f(:,1:m-1,4)=f(:,2:m,4);f(2:n,2:m,5)=f(1:n-1,1:m-1,5);f(1:n-1,2:m,6)=f(2:n,1:m-1,6);f(1:n-1,1:m-1,7)=f(2:n,2:m,7);f(2:n,1:m-1,8)=f(1:n-1,2:m,8); 这种实现和第一种没有本质区别。只是代码显得更简洁。但是如果向其他离散形式进行拓展，比如像三维D3Q15这种就不适合了，需要手动写很多代码。所以一个更简单，推广性更好的实现是使用数组平移函数circshift。 3 使用circshiftcircshift是一个数组平移函数。 这种方式circshift是一个循环平移函数，这里的循环实际上我们并不需要。 假设a=[1,2,3,4,5]，我们执行b=circshift(a,1)会得到： circshift 讲道理，我们不需要把5移动到b(1)，而希望b(1)=a(1)。所以执行完这个以后，需要对边界进行处理。 代码如下： 12345678910for i=1:9 b(i)=circshift(f(:,:,i),[cx(i),cy(i),0]); #x和y的起始点 qsdx=1+0.5*(cx(i)^2+cx(i)); qsdy=1+0.5*(cy(i)^2+cy(i)); #x和y的终点 zdx=n+0.5(cx(i)-cx(i)^2)); zdy=m+0.5(cy(i)-cy(i)^2)); f(qsdx:zdx,qsdy:zdy)=b(qsdx:zdx,qsdy:zdy);end 这里构造了起始点和终点函数。想象一下，假设平移向量是（1，-1）。那么我们需要的是在x方向从2到n，在y方向需要的是从1到m-1。于是构造了起始点和终点的函数分别为： $$x_{qsd} = 1 + { {c{x^2} + cx} \\over 2}$$ $${x_{zd}} = n + { {cx - c{x^2} } \\over 2}$$ 这里给的是x方向的，y方向的构造一模一样，只不过cx改为cy，n改为m而已。把平移函数cx=1，cy=-1代入公式，可以得到起始点和终点为： $$\\eqalign{ & x = 2:n \\cr & y = 1:m - 1 \\cr}$$这和我们需要的数据是一模一样的。这个方法的拓展性比较好，不需要针对不同的离散格子模型全部重写代码。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"matlab","slug":"matlab","permalink":"hxblog.top/tags/matlab/"},{"name":"LBM","slug":"LBM","permalink":"hxblog.top/tags/LBM/"}]},{"title":"一台电脑连接两个GitHub账户","slug":"一台电脑连接两个GitHub账户","date":"2019-03-30T07:23:36.000Z","updated":"2019-05-28T02:37:07.574Z","comments":true,"path":"post/6eab7de2.html","link":"","permalink":"hxblog.top/post/6eab7de2.html","excerpt":"由于要连接两个GitHub的账号，需要添加两个ssh。相关的步骤如下。","text":"由于要连接两个GitHub的账号，需要添加两个ssh。相关的步骤如下。 1 生成两个秘钥先到ssh目录下，一般是：C:\\Users\\你的电脑用户名\\.ssh，比如我的是：C:\\Users\\Hexin\\.ssh。然后在该目录下调出Git，依次输入一条然后分别回车：12ssh-keygen -t rsa -f ~/.ssh/秘钥名称1 -C \"邮箱1\"ssh-keygen -t rsa -f ~/.ssh/秘钥名称2 -C \"邮箱2\" 比如我的用户名一个是YXM，一个是HJJ，那么就是如下的代码：12ssh-keygen -t rsa -f ~/.ssh/id_rsa_YXM -C \"YXM@qq.com\"ssh-keygen -t rsa -f ~/.ssh/id_rsa_HJJ -C \"HJJ@qq.com\" 注意，秘钥名称你可以随意选取，自己知道就好。只要是两个不一样的就行。没必要一定和邮箱名一样，也不用在前面强制性加上id_rsa_这个前缀。 2 配置秘钥先生成配置文件，在Git中输入：touch config。然后打开这个config文件，进行编辑。 1234567891011#第一个账号Host YXM.github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa_YXM #第二个新账号Host HJJ.github.com HostName github.com User git IdentityFile ~/.ssh/id_rsa_HJJ 基本就是按照这个格式改写就行。注意host的名称任意，你认识就好。要注意的是把后面的秘钥文件改成你生成的那两个。 3 添加秘钥执行命令：12ssh-add ~/.ssh/id_rsa_YXMssh-add ~/.ssh/id_rsa_HJJ 如果出现错误提示： Could not open a connection to your authentication agent. 则先执行：1ssh-agent bash 然后在执行添加秘钥的命令。最后把这两个秘钥添加到GitHub的仓库里面的SSH Key里面去。在设置里面找到这个添加就行。 添加ssh key title随便取。第二个框里面把文件id_rsa_YXM.pub里面的内容复制粘贴进来就行。如果是要添加博客里面的deploy key的话先找到博客仓库的设置，在设置里面添加key。过程可以看之前的文章也谈Hexo+Github创建独立博客，里面提到如何添加deploy sshkey。 测试一下看看是否能连接上： 12ssh -T git@YXM.github.comssh -T git@HJJ.github.com 成功的话如下图： ABHN8I.png 4 在hexo中修改deploy的配置项如果是推送到博客的话，就需要对配置项里面的deploy项进行修改： 1234deploy: type: git repository: git@YXM.github.com:你的用户名/你的用户名.github.io.git branch: master 原来的是没有“YXM”的。原来的应该是这样： 1234deploy: type: git repository: git@github.com:你的用户名/你的用户名.github.io.git branch: master 本文参考了以下两篇文章，向他们表示感谢： Permission denied (publickey). fatal: Could not read from remote repository. 一台电脑使用两个或多个 GitHub 账号部署两个或多个 Hexo 博客 多个github帐号更新多个hexo博客 第二、三篇文章足够详细，建议参考。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Github博客搭建系列","slug":"Github博客搭建系列","permalink":"hxblog.top/categories/Github博客搭建系列/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"hxblog.top/tags/hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"hxblog.top/tags/GitHub/"}]},{"title":"Hexo博客个性化的一些东西","slug":"Hexo博客个性化的一些东西","date":"2019-03-28T10:44:28.000Z","updated":"2019-05-22T02:06:44.872Z","comments":true,"path":"post/577ffcb3.html","link":"","permalink":"hxblog.top/post/577ffcb3.html","excerpt":"记录一些博客搭建的小知识。本文持续更新5.14更新：增加文章永久链接5.22更新：增加文章置顶","text":"记录一些博客搭建的小知识。本文持续更新5.14更新：增加文章永久链接5.22更新：增加文章置顶 1 加入Valine评论系统 Valine – 一款极简的评论系统 leancloud 教程：官网就有，不过官网是针对一般的博客而言的。如果自己的主题自带对valine的支持的话是可以直接在配置中填写好的。我用的主题正好支持，所以只要填写相关的配置就好了。如果主题不支持，那就得自己弄了，要修改layout，虽然也不是很难，但是主题支持最好。 主题配置范例： 1234567891011# Valine Comment system. https://valine.js.orgvaline: enable: true # 如果你想使用valine，请将值设置为 true appId: # your leancloud appId appKey: # your leancloud appKey notify: false # Mail notify verify: false # Verify code avatar: mm # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide placeholder: 欢迎评论！ # Comment Box placeholder guest_info: nick,mail,link # Comment header info pageSize: 10 # comment list page size 2 添加emoji支持要做两个事： 安装emoji插件：这里用的是hexo-filter-github-emojis 增加配置（根目录下的配置文件） 使用方法官网都可以看到。 安装 1$ npm install hexo-filter-github-emojis --save 配置文件修改：在根目录config文件中增加： 123456githubEmojis: enable: true className: github-emoji inject: true styles: customEmojis: 3 关于插入图片我觉得好用的是两种。一种来自于hexo官方的采用资源文件夹的方法；一种是利用Markdown语法实现的外链图片插入方法。 内部文件法： 外链法： 3.1 先说内部文件法在配置文件中加入： 1post_asset_folder: true 每新建一个post都会在post文件里建一个和文章标题一样的子文件夹，图片就放在那里，需要引用的时候添加如下代码：1{% asset_img example.jpg title %} 3.2 外链法对于一些不太重要而又很大的图片，用这个比较好。因为加载速度快。 插入外链图片的代码： 1![title](URL) 两个比较好用的图床： 小贱贱图床 图床网址 小贱贱图床速度比较快；路过图床注册账号后可以添加文件夹。并且可以直接生成Markdown代码，如下图： 路过图床 此外路过图床可以设置图片是否对外可见。感觉不是很重要的，又比较大的图片放在小贱贱图床比较好。然后稍微重要的放路过，不可丢失的图片放在资源文件夹。而其实最安全的是云存储+图床。 暂时这么多吧。。。以后再更新。（2019.3.28） 4 live2D（3.30更新）加一个看板娘，好萌啊。还有公主殿下，啊，我等骑士团。。。 hexo-helper-live2d 这里面使用方法将的很清楚了，为了以后不再翻网页，直接把东西copy在这里。 首先需要安装这个插件： 1npm install --save hexo-helper-live2d 然后需要选择需要的模型。(模型预览) 1npm install --save live2d-widget-model-xxx 在配置中添加： 1234567891011121314151617181920# 看板娘live2d: # 固定写法，具体用途参阅下方文档 enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: # 这里根据已安装的素材包填写，如：live2d-widget-model-z16 use: live2d-widget-model-miku # 摆放位置 display: position: right width: 150 height: 300 mobile: show: true OK，完美！哦对了，据测试要放在根目录下的config文件才有效。为了这个弄了半天才弄明白。。。其实放在主题目录和根目录下的config应该都是可以的，我第一次用是在根目录下，然后改到主题目录下的config，结果改了相关的参数但是没有用。后来在根目录下的config改了才生效，值得注意。 5 文章的永久链接参考教程： 作者：雨临Lewis来源：CSDN原文：https://blog.csdn.net/lewky_liu/article/details/80517635 需要安装插件： 1npm install hexo-abbrlink --save 根目录下的配置： 123456# permalink: :year/:month/:day/:title/# permalink_defaults:permalink: posts/:abbrlink.htmlabbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 6 增加文章置顶参考TIMD的教程，在此感谢他。 作者：TIMD来源：CSDN原文：https://blog.csdn.net/weixin_42556146/article/details/80836875 修改Hexo文件夹下的node_modules/hexo-generator-index/lib/generator.js，在生成文章之前进行文章top值排序。即在var posts = locals.posts.sort(config.index_generator.order_by)之后插入下面的代码。 需添加的代码： 12345678910posts.data = posts.data.sort(function(a, b) { if (a.top && b.top) { // 两篇文章top都有定义 if (a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 } else if (a.top && !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; } else if (!a.top && b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排}); 最终的代码： 12345678910111213141516171819202122232425262728293031'use strict';var pagination = require('hexo-pagination');module.exports = function(locals) { var config = this.config; var posts = locals.posts.sort(config.index_generator.order_by); posts.data = posts.data.sort(function(a, b) { if (a.top && b.top) { if (a.top == b.top) return b.date - a.date; else return b.top - a.top; } else if (a.top && !b.top) { return -1; } else if (!a.top && b.top) { return 1; } else return b.date - a.date; }); var paginationDir = config.pagination_dir || 'page'; var path = config.index_generator.path || ''; return pagination(path, posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } });}; 之后，只需要在文章加入top属性就行了，排序从小到大。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Github博客搭建系列","slug":"Github博客搭建系列","permalink":"hxblog.top/categories/Github博客搭建系列/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"hxblog.top/tags/hexo/"}]},{"title":"Maple学习笔记：求解方程相关（更新。。。）","slug":"Maple学习笔记：求解方程相关（更新。。。）","date":"2018-10-19T08:01:06.000Z","updated":"2019-03-30T08:19:13.071Z","comments":true,"path":"post/edc1ad1c.html","link":"","permalink":"hxblog.top/post/edc1ad1c.html","excerpt":"方程——方程组——常微分方程——偏微分方程","text":"方程——方程组——常微分方程——偏微分方程 1 求解方程格式 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"Maple","slug":"Maple","permalink":"hxblog.top/tags/Maple/"}]},{"title":"Maple学习笔记","slug":"Maple学习笔记","date":"2018-10-16T15:53:46.000Z","updated":"2019-03-30T08:19:04.119Z","comments":true,"path":"post/d5673d21.html","link":"","permalink":"hxblog.top/post/d5673d21.html","excerpt":"最近推导公式，所以自学了Maple。真是个强大的东西。还有很多待学习的地方。暂时记录一些自己容易忽略的东西，便于查找。","text":"最近推导公式，所以自学了Maple。真是个强大的东西。还有很多待学习的地方。暂时记录一些自己容易忽略的东西，便于查找。 1 输入相关1.1 乘法 空格号以为着隐式乘号 在很多字符的情况下，或者含有表达式的情况下，使用显示乘法更能防止出错 x y=x*y xy:定义了一个“xy”的变量 1.2 输入表达式 可以在面板中选择表达式，用tab键转移到下一个占位符进行输入 不用再拿鼠标移动到那一点去输入 1.3 补全输入 和其他的语言一样，输入首个字母可以自动补全剩下的 输入首几个字符后，可以按回车键直接输入提示的字符 按下ESC键弹出下拉供选择的补全方案 除了补全已有的变量之外，还可以补全字符 1.4 输入公式标签 Ctrl+L会弹出插入公式标签的对话框，在对话框中输入公式编号即可 1.5 关于赋值 赋值语句“:=”，冒号不能少，否则变成等式 要让语句执行不输出，在语句后面添加冒号“：” 1.6 插入空语句 按住shift后再回车。否则直接执行当前命令。 1.7 数学和文字的区别 按住Ctrl和T，可以切换为文字输入 数学下的东西可以执行，文字环境下的东西不能执行，可以作为注释 数学下的光标为斜体，文字环境下的为直立 1.8 输入下标 Ctrl+Shift+“_”：Ctrl+Shift+下划线 1.9 输入指数 输入“^” 1.10 输入希腊字母 Ctrl + Shift + G 调节到输入希娜字母 希娜字母和字母的对照表如下图 基本上是发音的首字母 2 绘图2.1 调用格式：plot (f(x), x=xmin .. xmax); plot (f(x), x=xmin .. xmax, y=ymin .. ymax); plot ([f1(x), f2(x), …], x=xmin .. xmax); plot (f(x), x=xmin .. xmax, option); 其中， xmin..xmax 为 x 的变化范围， ymin..ymax 为 y(即 f(x))的变化范围。 option 选项参数主要包含^1： axes：坐标轴类型：FRAME，FRAME，NORMAL，NONE color：颜色 coords：坐标系：笛卡尔（cartesian），极坐标（polar），双极坐标系(bipolar)、 对数坐标（logarthmic） labels：坐标轴名称 linestyle：设定所绘线条的线型(linestyle=n, n 为 1 是实线, 2 为点, 3 为虚线, 4 为虚线与点交错) scaling：设置 x 与 y 轴的比例(unconstrained 非约束， constrained 约束，比例为 1:1) style：设定图形的显示样式(LINE(线形)、 POINT(点)、 PATCH(显示多边形与边线)、 PATCHNOGRID(只显示色彩而无边界) symbol：设定点的格式，主要有 BOX(方块)、 CROSS(十字)、 CIRCLE(圆形)、 POINT(点)、 DIAMOND(菱形)等几项 thickness：设定线条的粗细(0、 1、 2、 3 几种参数, 数值越大线条越粗) tickmarks：设定坐标轴刻度的数目(设定 tickmarks=[m, n], 则 x 轴刻度为 m, y 轴为 n) view：设定屏幕上图形显示的最大坐标和最小坐标，缺省是整个曲线 下面是对一些关键参数的详细记录。 2.2 颜色： 关键字：color 常用的颜色：black blue navy coral cyan brown gold green gray grey khaki magenta maroon orange pink plum red sienna tan turquoise violet wheat white yellow 2.3 线型2.4 坐标轴名称及图表名称 labels=[x, y]：坐标轴名称，x,y分别代表x轴和y轴的名字 title = titlename 2.5 字体控制 有四个部分的字体控制：font（图形内的字体），titlefont（标题字体），axesfont（坐标轴），labelfont（坐标轴标题） 字体控制的格式都是一样的： 控制字=[font,style,size] font指定字体，style指定字体样式（斜体、粗体等），size指定字体大小，直接填写数字即可 字体和样式如下表，其中SYMBOL没有样式 SYMBOL TIMES COURIER HELVETICA ROMAN DEFAULT DEFAULT BOLD BOLD BOLD ITALIC OBLIQUE OBLIQUE BOLDITALIC BOLDOBLIQUE BOLDOBLIQUE 一个例子： 1plot(y1, color = black, axes = NORMAL, title = U-ruo, linestyle = 1, font = [TIMES, ITALIC, 10], axesfont = [COURIER, OBLIQUE, 10], titlefont = [HELVETICA, BOLD, 10], labelfont = [TIMES, OBLIQUE, 20]) 2.6 坐标轴选项 对数坐标： logplot：y轴对数坐标 loglogplot：x，y都是对数坐标 semilogplot：x轴是对数坐标 注意：采用对数坐标的时候必须要在前面添加“with(plots)”选项 一个例子： > with(plots); > logplot({exp(x), exp(x^2), exp(3*x+1)}, x = .1 .. 10, y = 1 .. 10^6); 2.7 绘制多个图形标准做法有两种，随意看看结果的做法有一种。 2.7.1 利用display 要记得加上“with(plots)” 123456789with(plots):Plot3 := semilogplot(P3mm, color = \"Blue\", legend = \"H0=3mm\"):Plot4 := semilogplot(P4mm, color = \"black\", legend = \"H0=4mm\"):Plot5 := semilogplot(P5mm, color = \"yellow\", legend = \"H0=5mm\"):Plot6 := semilogplot(P6mm, color = \"green\", legend = \"H0=6mm\"):Plot10 := semilogplot(P10mm, color = \"orange\", legend = \"H0=10mm\"): Plot120 := semilogplot(P120mm, color = \"Red\", legend = \"H0=120mm\"): Plot240 := semilogplot(P240mm, style = point, color = \"black\", legend = \"H0=240mm\"):display({Plot10, Plot120, Plot240, Plot3, Plot4, Plot5, Plot6}, view = [0.2e-1 .. 10, 5 .. 50], axes = boxed, scaling = constrained, title = \"U-ruo\") 2.7.2 利用一个plot绘制出两个图1234567with(plots);logplot([exp(x), exp(x^2), exp(3*x+1)], x = .1 .. 10, y = 1 .. 10^6, legend = [typeset(exp(x)), typeset(exp(3*x+1)), typeset(exp(x^2))]);logplot([exp(x), exp(x^2), exp(3*x+1)], x = .1 .. 10, y = 1 .. 10^6, legend = [\"1\", \"2\", \"3\"])上述两种只是图例表达不一样 2.7.3 直接选中一个表达式，拖到一个现有的图中。 这种方式可以用来暂时进行比较 2.8 图例 关键字：legend 构造形式1：如2.7.1中的例子 1legend=“图例名称” 构造形式2：如2.7.2中的例子 1legend = [\"图例名1\", \"图例名2\", \"图例名3\"] 图例还有一个关键字：legendstyle，包括了字体大小和图例位置 123legendstyle = [font = [\"HELVETICA\", 9], location = right]完整例子：logplot([exp(x), exp(x^3), exp(3*x+1)], x = .1 .. 10, y = 1 .. 10^6, font = [legend, \"HELVETICA\", \"ROMAN\", 12], legendstyle = [font = [\"HELVETICA\", 12], location = bottom], thickness = 4, style = [point, point, point], legend = [\"1\", \"2\", \"3\"]) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"Maple","slug":"Maple","permalink":"hxblog.top/tags/Maple/"}]},{"title":"生酮食物","slug":"生酮食物","date":"2018-09-07T01:55:19.000Z","updated":"2018-09-07T09:39:14.000Z","comments":true,"path":"post/8e65c912.html","link":"","permalink":"hxblog.top/post/8e65c912.html","excerpt":"生酮食物就是低糖高优质脂肪的食物。记录一些常见的适用于减肥的生酮食物。","text":"生酮食物就是低糖高优质脂肪的食物。记录一些常见的适用于减肥的生酮食物。 一些已经有过总结的文章： 生酮入门：该吃的和不该吃的 常见食物碳水含量表|生酮减肥 GI和食物生糖指数|生酮减肥 生酮饮食金字塔：图片来源于知乎的老虎健康，特此感谢。 这个图说的很明白，就是少吃主食，精细粮食，多吃蔬菜，多吃肉。多吃肉很关键，要提供高质量的脂肪。一下子想不到那么多食品，其实是在食堂可以买得到的食物。因此，会在后续的时间陆续增加。 1 食物类别：肉：均可，除油炸，一定要多吃肉。鸡蛋：煮鸡蛋优先蔬菜：叶子菜优先，西兰花优先饮料：豆浆，绿豆汤水果：糖分含量低的水果，牛油果最优。坚果：除花生。其余待补充。 2 食堂生酮均衡餐不想完全生酮，还是稍微均衡一点吧。谁让我爱吃米饭呢。 早餐可以吃的： 牛奶，豆浆，绿豆汤，鸡蛋，玉米，红薯，紫薯 中餐 少量米饭（1两） 蔬菜：西兰花，胡萝卜，白萝卜（土豆类少吃） 肉类：烤鸡腿，烤鸡翅（不能吃骨肉相连，炸鸡腿等） 其他：豆干，豆皮都可以 晚餐 绿豆汤 粗粮： 紫薯、玉米 肉类：烤鸡翅，烤鸡腿 煎鸡蛋 以上：随时补充。 关于生酮减肥的一些好文章： 【生酮理论】生酮减肥的原理-师姐 【生酮入门】生酮饮食必读-师姐 师姐的文章都是好文章 后续还再补充一些关于生酮的东西，比如爆碳。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"生活","permalink":"hxblog.top/categories/生活/"}],"tags":[{"name":"减肥","slug":"减肥","permalink":"hxblog.top/tags/减肥/"},{"name":"生酮","slug":"生酮","permalink":"hxblog.top/tags/生酮/"}]},{"title":"关于减肥","slug":"关于减肥","date":"2018-09-06T16:02:27.000Z","updated":"2018-09-06T16:44:01.000Z","comments":true,"path":"post/c8dcfc3f.html","link":"","permalink":"hxblog.top/post/c8dcfc3f.html","excerpt":"最近看了不少关于减肥的东西。在此记录下来。 减肥的有效方式，是科学的运动+合理的饮食结构。","text":"最近看了不少关于减肥的东西。在此记录下来。 减肥的有效方式，是科学的运动+合理的饮食结构。 1 减肥的运动方式运动方式目前了解到的有三个主流： HIIIT：高强度间歇式运动。 这种运动燃脂比较快，在运动后持续1-2个小时还能持续燃脂。在硬派健身里面被洗脑严重。 HIIT还有一个特点，在运动时主要消耗糖分，对脂肪消耗并不高。其消耗脂肪的主要阶段在运动后。其主要原理在于EPOC（运动后过氧消耗效应）。 问题就是：容易反弹。在瘦下来后如果不持续的进行HIIT很容易反弹。 这个方法自己尝试过将近一个月，效果很是微乎其微。 力量训练，增加肌肉，提高基础代谢 这个是一个可以持续的方法，并且不容易反弹。肌肉每秒消耗的能量远大于肥肉。这点毋庸置疑。 慢跑 核心观念1：慢跑过程中脂肪消耗占比很高； 核心观念2：长时间的慢跑可以改变人的能耗方式。越是经常进行低强度训练，越容易使人变成燃脂的体质，即运动的减脂效果越来越好。 跑步是我在大学时期减肥成功并且长时间维持好身材的最主要的手段。那个时候没有接触HIIT，也没有做力量训练，只是跑步。但是要说明的是，我并不是慢跑。而且也没有做长时间的跑步。每次跑步大概只是在10分钟左右，四圈。为了让自己跑的更快，常常维持在9分钟30秒左右，这是一个比较快的速度。当然刚刚开始的时候还是很慢的。 但是在近期，也就是去年的时候，慢跑的确使我瘦了。只可惜只有一个开端，并没有好好坚持下去。 为了保证运动减肥的可持续性，我选择力量训练+长期的慢跑。力量训练提高基础代谢能力，长期的慢跑在于改变自己的体质，使得自己在运动时燃脂的效率更高。注意，这里是长期的慢跑，是指经常性的养成习惯的慢跑，不是一次慢跑长时间。 2 饮食 首先节食是不对的。 节食会降低人的基础代谢。此外，由于长时间的能量摄入少了，身体会慢慢的往容易吸收，容易把多余的糖分转化为脂肪这样的体质发展，渐渐适应这种“吃不饱”的生存环境，因此反弹会十分的严重。 少吃多餐 这一点有带考究。 勤喝水 喝水有助于代谢，提高自己的能耗。 生酮减肥 这个就大有来头了，看了不少资料，觉得这个方法有一定持续性，但是需要温和的执行。其核心观点就是通过控制饮食来模拟人类饥饿的状态，但实际上人并不感觉到饿。长期维持这样的饮食结构，就可以让自己的能耗方式由燃糖转变为燃脂。 生酮的意思就是摄入低糖高脂的食物。说白了就是不吃饭，不吃面这种主食，含碳水化合物比较多的食物。多吃蛋白质，脂肪高的食物。这样人就会在身体的糖原消耗掉了之后开始以消耗脂肪的方式来为身体功能。这个过程是漫长的，需要有耐心。因为人的体质转变需要时间。 期间会出现一些不良的反应，比如低血糖，比如精神不好什么的。坚持过去就好了。有人甚至发现，采用低酮的饮食方法比运动更有效。确实，人的身体的是适应性是很强的。 3 执行3.1 运动运动采用习惯性的低强度运动+力量训练这种可持续的方式进行。 低强度运动：MAF方法。这一块在了解了之后可以再写一写。 但是可操作性的就是： 持续运动在最大有氧心率 —（最大有氧心率的区间-10） 最大有氧心率=180-年龄。 我的年龄是29岁，最大有氧心率算是150，因此持续运动的区间就是： 135-150 每周跑步+爬瑜伽山5天 力量训练：俯卧撑，深蹲，平板支撑，引体向上（等瘦下来再说吧，现在不太可能） 每周力量训练3-5次。 3.2 饮食早餐： 小米粥一碗，鸡蛋两个中餐： 肉+蔬菜+蔬菜+1两米饭（三个菜）晚餐： 紫薯+煎鸡蛋+鸡腿或者鸡翅 暂时先这样，实验一个月。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"生活","permalink":"hxblog.top/categories/生活/"}],"tags":[{"name":"减肥","slug":"减肥","permalink":"hxblog.top/tags/减肥/"}]},{"title":"笔记：ANSYS里的双向FSI（基于系统耦合器）","slug":"笔记：ANSYS里的双向FSI（基于系统耦合器）","date":"2018-06-24T14:04:01.000Z","updated":"2018-09-06T15:08:59.000Z","comments":true,"path":"post/aeb8e519.html","link":"","permalink":"hxblog.top/post/aeb8e519.html","excerpt":"这应该是第一篇，关于系统耦合器的一些说明。","text":"这应该是第一篇，关于系统耦合器的一些说明。 1 系统耦合器概况System Coupling component-系统耦合器 多个计算单元耦合协同仿真分析是负责数据传递的一个组件。 可以耦合计算如下单元： Steady-State Thermal Transient Thermal Static Structural Transient Structural Fluid Flow (Fluent) Fluid Flow (CFX) External Data：外部数据 双向FSI这里采用的是： 瞬态动力学（Transient Structural）+Fluent 模块搭建如下图： 2 系统耦合器分析的设置2.1 分析类型 General：通常 只适用与参与耦合计算的模块有一个或两个以上采用稳态或静力学分析 但是，稳态、静力学分析和瞬态动力学分析的混合分析不允许。这也就是说只有两者都采用稳态、静力学分析才可以用这种类型。 Transient：瞬态 只适用于参与耦合计算的模块都采用瞬态分析，目前来说都是这一种。 2.2 时间控制Duration Defined By 有两种： End Time：针对Transient瞬态类型，以终止时间作为终止计算条件 Number of Steps：针对general类型，以计算步数作为终止计算条件 需要注意区分的两个概念：coupling steps：耦合步coupling iteration：耦合迭代步 耦合步里面包含了一个或者多个耦合迭代步。耦合步是时间推进的一步。 耦合迭代步的主要作用是在一个时间步（耦合步）内使流体和固体达到收敛。 数据传递发生在每个耦合迭代步的开始。 这里有两幅图，可以非常清晰的表明这两者的区别： 2.3 数据传递的设置Data Transfer Control 选取了数据传递面之后，数据传递的参数就已经设定好了。这里主要是将在“Data Transfer Control”里面的松弛因子（Under Relaxation Factor）的设置。 Under Relaxation Factor：数据传递的松弛因子。通常在瞬态动力学中用1。在稳态FSI工况中选取0.5。如果在瞬态工况不稳定，造成求解不稳定，可以选取小于一的松弛因子。但不建议取得太低，通常不能低于0.75。 RMS Convergence Target：收敛控制，一般默认为0.01。这个一般不需要更改。 Ramping：阻尼，如果有震荡，可以设定“Linear to Minimum Iterations”，默认的为none。none的话在所有的耦合迭代中，所有数据全部加载到目标。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"ANSYS","slug":"ANSYS","permalink":"hxblog.top/tags/ANSYS/"}]},{"title":"hexo：本地与网络显示不一致的原因","slug":"hexo：本地与网络显示不一致的原因","date":"2018-06-23T06:47:21.000Z","updated":"2019-03-30T08:12:44.039Z","comments":true,"path":"post/9c4edf71.html","link":"","permalink":"hxblog.top/post/9c4edf71.html","excerpt":"最近发现了一个问题，修改了hexo的默认主题（landscape）之后，有些在本地能正常显示，部署到网络却发现不能显示。比如公式，分享按钮等。关键在于HTTP和https的问题。","text":"最近发现了一个问题，修改了hexo的默认主题（landscape）之后，有些在本地能正常显示，部署到网络却发现不能显示。比如公式，分享按钮等。关键在于HTTP和https的问题。 1 闲话在前之前的主题（indigo）非常好看，但是对公示支持不好。他本身应该是支持mathjax的，但不知道为啥，显示出来总有些问题。 看了下大概是采用less作为预处理，并采用less渲染的问题。换个渲染这个主题就不能用了，很可惜。挑来挑去还是觉得默认的主题比较简洁，也实用。慢慢在这个主题上增加自己需要的功能。 2 问题出现把百度分享和mathjax加入到了主题里。localhost:4000可以正常显示，部署到网络后，发现既公式不能正常显示，又没有分享按钮。其原因还是访问的是采用https的模式。而这里面的有些js是HTTP访问加载的。 其实要找到原因，或者说找到这种类似问题的原因，可以去控制台看看： Chrome：对浏览器点右键，检查，console（控制台） Foxfire：点右键，查看元素，控制台 上面就会显示出出错的原因： 3 解决方案其实就是要解决在https下面请求HTTP资源的问题。 百度了一下，ChanceWong的帖子有一些解决方案。我会的也就是只有参考相对协议的办法了。 就是找到相关的js代码，把src后面的网址的http:删除即可。具体的操作可以参考上面帖子的说明。 然而这种方法有一个前提，就是你的博客需要支持HTTP访问才行。如果锁定HTTPS，并且你要加载的js只能HTTP访问的话，那是不行的。 还有一种解决方案就是把你需要的js下下来，放在博客的public目录下。 4 百度分享的https解决方案百度的share.js已经有人弄好了。项目地址和使用说明都有，写的很详细，而且也给出了自己从网上获取js的办法。这点很好，万一你用的不是百度分享，你也有解决方案。 github地址 使用说明 这里需要注意的是： static文件夹不是放在你博客目录的根目录下，而是放在public目录下，因为我们的是hexo。 每次clean后static就没了，要重新拷贝，建议在博客目录下保存一份 如果是自己提取的，static文件里面的有些内容要修改，详见链接里面的说明。如果是直接从这位作者的github里下下来的，则不需要做任何修改了 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Github博客搭建系列","slug":"Github博客搭建系列","permalink":"hxblog.top/categories/Github博客搭建系列/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"hxblog.top/tags/hexo/"}]},{"title":"气体的状态方程","slug":"气体的状态方程","date":"2018-06-14T14:17:42.000Z","updated":"2018-06-15T02:03:38.000Z","comments":true,"path":"post/c7f1a035.html","link":"","permalink":"hxblog.top/post/c7f1a035.html","excerpt":"气体的密度，压力和温度之间的关系。","text":"气体的密度，压力和温度之间的关系。 气体的密度表征的是单位体积气体的质量，相当宏观的一个定义。 温度的定义是气体分子平均动能的度量，相当微观的一个定义。 压力体现为一种使气体膨胀的趋势，也体现为气体对相邻固体或液体表面的推力作用，宏观 理想气体理想气体基于以下假设：气体分子本身的体积与分子之间的作用力可以忽略 其状态方程： $$p = \\rho RT \\tag 1$$其中，R 为气体常数。公式1表达了压力，密度和温度之间的关系。 根据动量定理，压力与单位时间内气体分子撞击壁面的动量，这个值与两个因数有关： $$p = \\begin{cases}m_iv_i, & 单个分子传递的动量 \\\\n , & 单位时间内发生碰撞的分子数\\end{cases}$$ $vi$和温度有关，温度越大，速度越大，至于分子的质量影响可以暂时忽略。也就是说，温度越大，动量越大。 $n$和分子的速度和密度有关，密度越高，单位体积内的分子数越多，分子速度越高，发生碰撞的次数越多，而分子的速度又和温度呈正相关。 不难得出，压力正比于密度和温度。可以反映在式1上。 可否压缩一般认为气体在低于0.3倍音速的流动中为不可压缩。 这个临界速度大约在112m/s。基本上都是不可压缩的。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"hxblog.top/categories/学习笔记/"}],"tags":[{"name":"流体力学","slug":"流体力学","permalink":"hxblog.top/tags/流体力学/"}]},{"title":"日记 2018/6/12","slug":"日记","date":"2018-06-12T15:55:43.000Z","updated":"2018-06-12T16:34:54.000Z","comments":true,"path":"post/3c303542.html","link":"","permalink":"hxblog.top/post/3c303542.html","excerpt":"有种深深的无力感…","text":"有种深深的无力感… 今天把编程指南过了一遍，然后在李东岳的博客里面看求解器的解析。 真的感觉无能为力啊。因为不懂的地方真的太多了，完全无从下手。原以为看下来一个基本的势流求解器(potentialFoam)和拉普拉斯求解器(laplacialFoam)应该还算简单，但是看下来还有太多的东西不了解。其中在用到laplacialFoam求解器的案例中居然连程序入口都找不到。 从各方面感受到了无力感。C++的基础，CFD已经很久没有搞了，也遗忘了很多。另外PISO算法这种投影法也已经忘的差不多了。 遇到不懂的，试图百度谷歌，真的关于OpenFOAM的东西太少了，有些问题如果要试图找到答案，好像只有阅读源代码这一条途径。然而阅读源代码，工作量大不说，还看不懂。OpenFOAM官方的 也许应该评估一下这条路是否应该继续走下去了。搞定OpenFOAM确实对于现在的我来说有非常大的难度。 或许应该和雷博交流一下。 明天，去把书还了，借一本有限体积法的了解一下PISO算法，争取搞懂这个基础的求解器。毕竟要实现IBM可能也需要这个求解器。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"个人记事","slug":"个人记事","permalink":"hxblog.top/categories/个人记事/"}],"tags":[{"name":"日记","slug":"日记","permalink":"hxblog.top/tags/日记/"}]},{"title":"上周复盘及日记","slug":"上周复盘及日记","date":"2018-06-11T13:58:49.000Z","updated":"2019-03-30T08:18:11.151Z","comments":true,"path":"post/9e41e8cc.html","link":"","permalink":"hxblog.top/post/9e41e8cc.html","excerpt":"花呗还完了，然而房贷得要凑了😂","text":"花呗还完了，然而房贷得要凑了😂 上周复盘 完成C++的快速过一遍 已完成，其实还是很有用的，至少理解代码上快一些，但是还是有很多不懂理解不了的地方 完成Openfoam编程指南，不懂的跳过吧 这个正在弄，还在开始阶段，希望能仔细看一看吧，过了一遍C++后看的效果跟以前比还是不一样了 向需要的人索要代码（至少3个人） 只发了一个人的邮件 发第二个人的邮件至少还是把人家的论文看完再发吧 pisoFoam和icoFoam最少要搞定一个 还没有开始。。。😂 很惭愧，这个任务量的完成情况来看确实糟糕。周六周日被文兄拉去打牌基本上浪费了两天的时间。虽然说周末可以休息一下，但是，时间不多了。。。😭 本周安排work 完成OpenFOAM编程指南 看看pisoFoam和icoFoam 发一个邮件，即看完那篇37页的文献。。。😭 虽然知道时间很紧张，但是造成现在的苦果也是自己的问题。不过多说无益，能抓住的只有现在。 猥琐发育，别浪！ 稳住，我们能赢！ Blog关于博客搭建系列： 短链接（永久链接） 为博客添加评论系统 Hexo中插入图片 Hexo+免费空间搭建博客 关于科研工作： 写一篇求解器的博文吧 日记小电驴的胎爆了，真是悲伤啊，在如此缺钱的情况下简直是雪上加霜…😭 买了两只真空胎，等胎到了，自己换胎。 😎 今天的效率并不高，很容易被打断，没有形成持续集中注意力来搞科研。 明天，继续看编程指南，细看，但不是慢看。注意区别，快还是要快一点过的。这个工作最多持续到周三结束。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"个人记事","slug":"个人记事","permalink":"hxblog.top/categories/个人记事/"}],"tags":[{"name":"总结","slug":"总结","permalink":"hxblog.top/tags/总结/"},{"name":"复盘","slug":"复盘","permalink":"hxblog.top/tags/复盘/"}]},{"title":"Hexo实现多标签","slug":"Hexo实现多标签","date":"2018-06-11T13:46:19.000Z","updated":"2019-03-30T08:12:03.269Z","comments":true,"path":"post/25bdb4d7.html","link":"","permalink":"hxblog.top/post/25bdb4d7.html","excerpt":"有时候一篇文章需要设定几个标签，hexo的实现方式是tags: [tags1,tags1,tags1]","text":"有时候一篇文章需要设定几个标签，hexo的实现方式是tags: [tags1,tags1,tags1] 多个标签在post里面的tags按照以下格式填写 tags: [tags1,tags1,tags1] 比如本文： 注意： 标签之间采用英文逗号分隔 hexo g之后，会自动变成如下的形式 因此，你也可以这样写多标签 tags: - blog搭建 - hexo 注意短线后有空格 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Github博客搭建系列","slug":"Github博客搭建系列","permalink":"hxblog.top/categories/Github博客搭建系列/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"hxblog.top/tags/hexo/"}]},{"title":"C++关键字：explicit（转载自网名还没想好的博客）","slug":"C-关键字：explicit","date":"2018-06-11T13:29:54.000Z","updated":"2018-06-11T13:38:06.000Z","comments":true,"path":"post/b8284c09.html","link":"","permalink":"hxblog.top/post/b8284c09.html","excerpt":"这里引用了一篇很好的文章。 explicit旨在保护数据转换的安全。使用explicit声明了的构造函数，不能隐式转换。","text":"这里引用了一篇很好的文章。 explicit旨在保护数据转换的安全。使用explicit声明了的构造函数，不能隐式转换。 原文链接：https://www.cnblogs.com/ymy124/p/3632634.html 为了防止文章以后找不到，在日志里拷贝一份。偷个懒，侵删。 首先, C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式). 那么显示声明的构造函数和隐式声明的有什么区别呢? 我们来看下面的例子: class CxString // 没有使用explicit关键字的类声明, 即默认为隐式声明 { public: char *_pstr; int _size; CxString(int size) { _size = size; // string的预设大小 _pstr = malloc(size + 1); // 分配string的内存 memset(_pstr, 0, size + 1); } CxString(const char *p) { int size = strlen(p); _pstr = malloc(size + 1); // 分配string的内存 strcpy(_pstr, p); // 复制字符串 _size = strlen(_pstr); } // 析构函数这里不讨论, 省略... }; // 下面是调用: CxString string1(24); // 这样是OK的, 为CxString预分配24字节的大小的内存 CxString string2 = 10; // 这样是OK的, 为CxString预分配10字节的大小的内存 CxString string3; // 这样是不行的, 因为没有默认构造函数, 错误为: “CxString”: 没有合适的默认构造函数可用 CxString string4(\"aaaa\"); // 这样是OK的 CxString string5 = \"bbb\"; // 这样也是OK的, 调用的是CxString(const char *p) CxString string6 = 'c'; // 这样也是OK的, 其实调用的是CxString(int size), 且size等于'c'的ascii码 string1 = 2; // 这样也是OK的, 为CxString预分配2字节的大小的内存 string2 = 3; // 这样也是OK的, 为CxString预分配3字节的大小的内存 string3 = string1; // 这样也是OK的, 至少编译是没问题的, 但是如果析构函数里用free释放_pstr内存指针的时候可能会报错, 完整的代码必须重载运算符\"=\", 并在其中处理内存释放 上面的代码中, “CxString string2 = 10;” 这句为什么是可以的呢? 在C++中, 如果的构造函数只有一个参数时, 那么在编译的时候就会有一个缺省的转换操作:将该构造函数对应数据类型的数据转换为该类对象. 也就是说 “CxString string2 = 10;” 这段代码, 编译器自动将整型转换为CxString类对象, 实际上等同于下面的操作: CxString string2(10); 或 CxString temp(10); CxString string2 = temp; 但是, 上面的代码中的_size代表的是字符串内存分配的大小, 那么调用的第二句 “CxString string2 = 10;” 和第六句 “CxString string6 = ‘c’;” 就显得不伦不类, 而且容易让人疑惑. 有什么办法阻止这种用法呢? 答案就是使用explicit关键字. 我们把上面的代码修改一下, 如下: class CxString // 使用关键字explicit的类声明, 显示转换 { public: char *_pstr; int _size; explicit CxString(int size) { _size = size; // 代码同上, 省略... } CxString(const char *p) { // 代码同上, 省略... } }; // 下面是调用: CxString string1(24); // 这样是OK的 CxString string2 = 10; // 这样是不行的, 因为explicit关键字取消了隐式转换 CxString string3; // 这样是不行的, 因为没有默认构造函数 CxString string4(\"aaaa\"); // 这样是OK的 CxString string5 = \"bbb\"; // 这样也是OK的, 调用的是CxString(const char *p) CxString string6 = 'c'; // 这样是不行的, 其实调用的是CxString(int size), 且size等于'c'的ascii码, 但explicit关键字取消了隐式转换 string1 = 2; // 这样也是不行的, 因为取消了隐式转换 string2 = 3; // 这样也是不行的, 因为取消了隐式转换 string3 = string1; // 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符\"=\"的重载 explicit关键字的作用就是防止类构造函数的隐式自动转换. 上面也已经说过了, explicit关键字只对有一个参数的类构造函数有效, 如果类构造函数参数大于或等于两个时, 是不会产生隐式转换的, 所以explicit关键字也就无效了. 例如: class CxString // explicit关键字在类构造函数参数大于或等于两个时无效 { public: char *_pstr; int _age; int _size; explicit CxString(int age, int size) { _age = age; _size = size; // 代码同上, 省略... } CxString(const char *p) { // 代码同上, 省略... } }; // 这个时候有没有explicit关键字都是一样的 但是, 也有一个例外, 就是当除了第一个参数以外的其他参数都有默认值的时候, explicit关键字依然有效, 此时, 当调用构造函数时只传入一个参数, 等效于只有一个参数的类构造函数, 例子如下: class CxString // 使用关键字explicit声明 { public: int _age; int _size; explicit CxString(int age, int size = 0) { _age = age; _size = size; // 代码同上, 省略... } CxString(const char *p) { // 代码同上, 省略... } }; // 下面是调用: CxString string1(24); // 这样是OK的 CxString string2 = 10; // 这样是不行的, 因为explicit关键字取消了隐式转换 CxString string3; // 这样是不行的, 因为没有默认构造函数 string1 = 2; // 这样也是不行的, 因为取消了隐式转换 string2 = 3; // 这样也是不行的, 因为取消了隐式转换 string3 = string1; // 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符\"=\"的重载 以上即为C++ explicit关键字的详细介绍. 本文转载自：https://www.cnblogs.com/ymy124/p/3632634.html 如有侵权，请联系博主删除。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"hxblog.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"hxblog.top/tags/C/"}]},{"title":"日记 2016/6/7","slug":"日记","date":"2018-06-07T14:35:25.000Z","updated":"2018-06-12T16:31:29.000Z","comments":true,"path":"post/3458e8f8.html","link":"","permalink":"hxblog.top/post/3458e8f8.html","excerpt":"2018-6-7 快要还花呗了哦~~","text":"2018-6-7 快要还花呗了哦~~ 昨日任务： 过完C++ 发邮件 今天没有完成昨天预定的任务，周六又被预定了有活动。这周的任务量是不可能完成了。 C++快看完了，就该这么看，看完了要啃一下代码了。 今天上午和下午倒腾了影视VIP网站的建立。网站是建好了，接下来咋办？慢慢耕耘吧。。。重点还是在学术上。。。 明日安排 结束C++ 发邮件 怎么看着还是昨天的任务。。。😂 至于其他的事情，随缘吧，赚不到就赚不到。。。毕竟推广还是比较难的。 思路可以慢慢想。 每日一句 00后都参加高考了，你看着办。 老男人 👨 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"个人记事","slug":"个人记事","permalink":"hxblog.top/categories/个人记事/"}],"tags":[{"name":"日记","slug":"日记","permalink":"hxblog.top/tags/日记/"}]},{"title":"近期总结和复盘","slug":"近期复盘","date":"2018-06-06T13:49:37.000Z","updated":"2019-03-30T08:17:56.768Z","comments":true,"path":"post/412f0a2.html","link":"","permalink":"hxblog.top/post/412f0a2.html","excerpt":"今天吃完晚饭之后和吴博交流了一下，感觉最近这段时间自己科研进展效率极低确实存在方法论上面的一些问题。今天决定对自己复盘一下，并对接下来的工作做一个安排和计划。","text":"今天吃完晚饭之后和吴博交流了一下，感觉最近这段时间自己科研进展效率极低确实存在方法论上面的一些问题。今天决定对自己复盘一下，并对接下来的工作做一个安排和计划。 1 此前计划和完成情况说实话，比较惭愧，目前看来，科研进展是相当的不顺利的。 投出去的文章目前还在寻找审稿人，石沉大海一般的状态很难指望，虽然当初邮件告诉我，一审要7个月，但是这确实要提前做好准备了 第二篇计划在今年9月份投出去。目前还没有啥想法。这个是比较危险的，因为现在已经6月份了。按照我之前的想法，要在7月份完成浸入边界法的实现，目前看来还有非常大的距离。至少还没有开始编程，这边还需要消化理解Openfoam的东西 大概贴出来一下自己的计划吧： 虽然看起来和计划偏离不大，但其实已经落后非常多了。在算法实现这一块还有非常多的工作需要做。 2 目前做法上存在的问题 效率低下：说实话，分心了。 过于拘泥于细节：最近已经快两个星期了，还在仔细的看C++。吴博指出来，这种方法太慢了，不能这样去做事情。应该直接去看算法，不懂的再回来看书。确实如此，这一点老板也经常这么批评我们。明明是一个工具性的东西，自己偏向的太多了。 目标不甚明确，左右摇摆：既想把IBM搞好，然后从里面做点创新发文章，但是又担心自己找不到创新。既想做纸张建模，又担心做了建模创新不够，同时由于问题太偏还是无法找到审稿人。 没有要到代码，想要自己完全编写下来，这是个近乎无法完成的任务，对于我这种代码小白来说。 问题挺多的。心塞中。。。 3 打算怎么做至于效率，还是不说啥了。别回家了，就在实验室带着睡吧。 以最快的速度过一遍C++。虽然可以要用的时候再来查，但是不过一遍心里还是没底。这是这一次，不要拘泥于细节了。 向IBM集成在openfoam里面的研究人员索要代码。最近这几天着重发邮件吧。 看完pisoFoam算法和icoFoam，直接从代码层面入手。 以后，每周做一次复盘吧。每日做一个计划，记录在博客里面。 4 本周安排 完成C++的快速过一遍 完成Openfoam编程指南，不懂的跳过吧 向需要的人索要代码（至少3个人） pisoFoam和icoFoam最少要搞定一个 加油吧，任务量有点多。 5 明天安排明天安排： 过一遍C++，不要写笔记了。。。营养量不够 发邮件，晚上开始。 6 一些想法纯粒子FSI处理 DSMC+IBM document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"个人记事","slug":"个人记事","permalink":"hxblog.top/categories/个人记事/"}],"tags":[{"name":"总结","slug":"总结","permalink":"hxblog.top/tags/总结/"},{"name":"复盘","slug":"复盘","permalink":"hxblog.top/tags/复盘/"}]},{"title":"也谈Hexo+Github创建独立博客","slug":"也谈Hexo-Github创建独立博客","date":"2018-06-04T06:52:26.000Z","updated":"2019-03-30T08:16:34.529Z","comments":true,"path":"post/e05079e9.html","link":"","permalink":"hxblog.top/post/e05079e9.html","excerpt":"这是利用Hexo和Github搭建博客系列的第一篇。它的目的是为搭建一个“最小系统”博客提供简洁实用的帮助。","text":"这是利用Hexo和Github搭建博客系列的第一篇。它的目的是为搭建一个“最小系统”博客提供简洁实用的帮助。 1. 写在前面关于利用Hexo+Github搭建独立博客的博文网上有非常多，感谢这些博主提供的帮助和相关的经验。即便如此，我在搭建博客以及修改博客的过程中仍然遇到了不少问题，因此本文的重点是把遇到的这些问题做一个补充。 所以本文主要是做的搬运工作，对大神小茗同学的博文做一些补充和精简。对于建立博客的要求不一样，工作量也不一样，本文写的主要针对于想要建立一个自己的小博客的这种，算是一个最小系统解决方案吧（不做域名绑定）。鉴于已经有很多大神写了相关教程，因此希望不要写的太长。 2 步骤2.1 hexo 和 Github是什么？屁话： Github: gitHub是一个面向开源及私有软件项目的托管平台，用git进行版本管理。 Hexo: 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 人话： Github你可以理解为一个云盘。git是版本管理工具，但是在这里，重点是git还可以把本地文件上传到这个云盘，也可以从云盘下载到本地（怎么做有具体的命令，这里只需要知道它能干这个活）。事实上，git可要深刻的多了。如果只是要搭建博客的话，暂时这么理解也没问题。 说白了，Hexo是一个博客框架，支持markdown语法，用处就是生成静态网页。再说白了，Hexo可以看成是一个工具，利用他你可以直接渲染生成一个本地的博客，这包括了博客的日志啊，分类啊，标签等功能的实现。比较重要的是，它还可以把生成的这个本地博客发送（部署）到云盘上去。 说到这里，搭建博客的原理就知道了：利用hexo生成博客，但是这个博客只能在本地访问，你想要在网上访问就得把生成的博客上传（git）到网上（Github）上去。这样你输入Github的地址就可以访问到你的博客了。但是值得注意的是，不是你随便放在云盘的哪个地方都可以显示出博客来的，为了显示博客，还需要做一些事情。 所以很简单，要搞定这件事，首先需要做两件事，建立一个本地的博客(Hexo)，搞定放博客的云盘(Github)。这两件事谁先谁后都可以，我建议先搞定第二个，即先搞好网盘工作。然后再搞定Hexo，最后将两者绑定起来。 2.2 搞定Github Pages仓库要让github显示你的网页，需要用到Github Pages,创建Github Pages使用的仓库。 首先得有个github的账号吧。在Github里创建一个账号，记住你的用户名（username）哦，比如你创建的用户名是XXXOOO记下来。 提示： 如果你不做域名绑定的话，那么你的这个用户名会体现到你的网址里面。所以要认真取好你的用户名，😏 比如，我的用户名是XXXOOO，那么我最后博客地址就是” { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Github博客搭建系列","slug":"Github博客搭建系列","permalink":"hxblog.top/categories/Github博客搭建系列/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"hxblog.top/tags/hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"hxblog.top/tags/GitHub/"}]},{"title":"C++笔记：对象的动态建立和释放","slug":"C-笔记：对象的动态建立和释放","date":"2018-06-03T09:53:07.000Z","updated":"2018-06-07T16:11:25.000Z","comments":true,"path":"post/72b05b11.html","link":"","permalink":"hxblog.top/post/72b05b11.html","excerpt":"new和delete","text":"new和delete 1 动态与静态所谓动态，就是只在堆里开辟内存和释放内存，而没有其余的特殊的动态的含义。 静态建立，是指程序在运行中，对象或者变量所占有的空间是在堆里面，不能随意的释放。 动态的建立和释放通过运算符new和delete来进行。注意，这俩不是关键字，是运算符，和“+”“-”这种东西一个性质 2 new运算符是干嘛的？如果已经定义了一个类，则可以用new来动态的建立一个对象。 new 对象名； 比如，已经有一个Student类，则以下语句： new Student； 这里，它做了两件事： 在堆里开辟一段内存空间，在这段空间里存放一个Student类的对象。 调用这个对象的构造函数，以使这个对象初始化。 返回一个指向这个对象的指针的值（就是起始地址，可不是指针变量哦） 但是直接new出来的东西既没有对象名，用户也不知道地址，是没法用的 因此，这个家伙通常这样来用： 类名 *p=new 类名； 还用Student类来说： Student *p= new Student; 这样，new出来的东西就可以用指针p来访问了。 3 delete运算符是干嘛的简单来说，删掉new出来的东西。但是删你也不知道删谁啊，所以一般是删掉new给的那个指针 delete p 释放p所指向的内存空间。不过要注意，这个指针p可能先指向一个new出来的对象，后来又指向了新new出来的对象，然后又可能指回去或者再指向new出来的对象，总之，删的是当前指向的那个对象，用的时候要注意，以免删错了。 实际上，delete做的事情不是这么简单，它做了以下的事情： 自动调用析构函数 释放内存空间 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"hxblog.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"hxblog.top/tags/C/"}]},{"title":"C++笔记：关于const关键字","slug":"C-笔记：关于const关键字","date":"2018-06-03T09:12:33.000Z","updated":"2018-06-07T16:11:25.000Z","comments":true,"path":"post/15616985.html","link":"","permalink":"hxblog.top/post/15616985.html","excerpt":"常变量，常指针，指向常变量的指针以及常引用。","text":"常变量，常指针，指向常变量的指针以及常引用。 1 const的作用 const关键字一般表示为常量。主要作用在于对共用数据的保护。将某个变量或者对象设为常量后，则无法使用函数或者语句来改变这个常变量或者常对象，以此来起到保护数据的作用 2 常变量和常对象2.1 常变量常变量的定义方法如下： const 变量类型 变量名; 以下这种定义方法等效： 变量类型 const 变量名; 2.2 常对象常对象的定义方法如下： const 类名 对象名 (实参列表); 以下这种定义方法等效： 类名 const 对象名 (实参列表); 常对象需要注意的是： 常对象其数据成员都不可以被改变，有特例，采用关键字mutable； 常对象不能调用其非const型的成员函数，不论这些非const型的成员函数是否改变对象的数据成员，只能用const型的成员函数。这是为了安全起见的，强制性规定这样，因为谁也不能保证那些非const函数是否真的不改变常对象的数据成员； 常成员函数可以访问常对象中的数据，但是不允许修改常对象中的数据成员； 常对象并不意味常对象里的数据成员都是常变量，两种是不同的概念； 常对象里面可以有非const型的成员函数。但是常对象不能使用她们； 常成员函数不能调用一个非const型的成员函数。 2.3 常数据成员与常成员函数常数据成员与一般的常变量的用法无异，即该数据成员的值是不能改变的。其声明需要在声明类的时候进行，因为限定的是类中的数据： const 数据类型 变量名词； 或者： 数据类型 const 变量名称； 常成员函数主要作用是为了配合常变量使用。因为常变量它只能使用常成员函数来访问对象的数据成员。 声明同样是需要在声明类的时候进行，不难理解，与此同时，在定义函数的时候，也需要使用const关键字。因此它需要在两个地方使用const关键字： 声明： 函数返回值类型 函数名（形参列表） const； 例如： void get_diff (int a, int b) const; 定义： 函数返回值类型 函数名（形参列表） const {} 例如： void get_diff(int a, int b){ return (a-b); } 需要注意的： 对于常数据成员，只能通过构造函数的参数初始化表对常数据成员进行初始化； 例如： Time::Time（int h,int m, int s）:hour(h),minute(m),second(s){} 而如下的做法是错误的： Time::Time(int h){ hour=h; } 因为常数据成员及常变量是不能被赋值的， 只能在初始化的时候给值。 const是函数类型的一部分，声明和定义都不能少，但是在调用的时候不能加上const关键字，按照普通函数一样调用即可。 3 常指针和指向常变量的指针这一块的内容非常容易被混淆，从核心上来理解： 常指针：是一个指针变量，并且这个东西是不能改变的。不能改变的是指针的地址，而不是地址指向的变量。 打个比方：你有一套房子，这个房子的地理位置是永恒不变的，愚公移山这种特例不管，但是这个房子里住的人可不是永恒不变的，所有常指针，就类似于这个房子。 指向常变量的指针：首先这不是是一个普通的指针，他是指向常变量的指针，虽然它的值当然是可以改变的，也就是说它指向谁都是可以的，不是固定的。但是不能用它来改变它所指向变量的值。 打个比方：这是一个可移动的房子，所以它的地址当然不是固定的，同时它既可以租给那些固执的人（const型的），也可以租给那些善变的（非const型的）。但是你却无法通过这个移动的房子去改变租客，尽管租客自己能改变自己。比喻有点牵强，但是能说明指向常变量的指针的特性。 既然说到了常指针，又说到了指向常变量的指针，那当然存在一个指向常变量的常指针了。这个比方非常好打，就是你有一套房子，只能给固定的人住，那么这个房子就是指向常变量（固定的人）的常指针（房子的地址不会改变）。 说了理解部分的，下面是一些规矩。 3.1 常指针声明：声明和初始化一起搞定。因为常指针也算是一个常变量，不能赋值，只能初始化。 变量类型 * const 指针变量名 = 指向的变量的地址 例如： int a = 10 ; int * const p = &a; 除了用在变量上，当然还可以用在类上。也就是指向类的常指针。 声明和指向变量的常指针没什么两样： 类名 * const 指针变量名 = 对象地址 例如： Time t1(10,30,55); Time * const pt = &t1; 3.2 指向常变量的指针声明： const 类型名 * 指针名； 或者指向常对象的指针： const 类名 * 指针名 3.3 常变量与指向常变量的指针首先要区别常指针和指向常变量的指针。这在开始已经介绍过，简单的来说其实可以归结为两句话： 指向常变量的指针——不能通过指针改变变量的值 指向变量的常指针——不能改变指针的值 其次，还有几点需要注意： 常变量必须要用指向常变量的指针变量来指向它 指向常变量的指针既可以指向常变量，也可以指向普通变量。只是不能通过指针来改变所指向变量的值 以下几个例子可以说明一定的问题： int a=10; int * const p1=&a;//指向变量a的常指针，必须在声明时赋值 int b=20; p1=&b;//这是错误的，p是常指针，不能改变 const int c=100； int *p2=&c;//错误，常变量不能用普通指针来指向它 int * const p3=&c;//错误，常变量也不能用常指针来指向它 const int *p4=&c;//正确，常变量必须要用指向常变量的指针来指向它 int d=200; p4=&d;//正确，指向常变量的指针也可以只想非const变量 *p=300;//错误，不能通过指向常变量的指针来改变所指向的变量 d=300;//正确 4 数据及对象的常引用以及常变量的引用const引用的声明如下： const 类型 &引用名=被应用的变量; //引用在声明时必须要初始化 首先回到引用的本质，引用即别名。也就是说引用是不能更改的，即一个别名不能用在两个人身上，也不能把一个别人用过的别名用到其他人身上。这就是说，引用一旦初始化后，和被引用的变量终生绑定。从这个特质来看，有点像常指针。指向那个对象，就得一直指向它。 值得注意的是：一个变量可以取多个别名啊~~~只是一个别名只能用在一个人身上。 而const引用则类似于指向常变量的常指针（注意这里不是指向常变量的指针，后者可以先后不止指向一个值）。也就是const引用既可以引用普通的变量，也能引用const变量。但是，这一点非常重要，和指向常变量的指针一样，不能通过const引用来改变其引用的变量的值。 来看例子： int a=10; const int b=20; int & c1=a;//没毛病 const int & c2=a; //没毛病，常引用自然可以引用非const变量 int & c3=b;//错误，常量必须要用常引用来引用 const int &c4=b;//没毛病，常量用常引用来引用 c2=30;//错误，虽然c2指向的a不是常变量，但是不能通过常引用来改变它的值 a=30;//没毛病，给他取个常引用的别名并不能让他成为常变量 结论：常变量必须要用常引用，常引用可以引用常变量也可以引用非常变量，但是不能通过常引用来改变所引用的变量的值。 5 在函数中的应用5.1 指针 如果函数的形参是指向非const型变量的指针，那么实参不能传递一个const变量的地址吗，也不能使用指向const变量的指针（即使其指向的对象是非const的）。只能用指向非const变量的指针，或者是非const变量的地址，当然，也可以是指向非const变量的常指针。这是因为传递过去的地址可能会在函数调用中改变该地址所指向变量的值，采用指向const变量的指针或者传递一个const变量的地址这都无法改变其所指向变量的值，这样会发生冲突，而在编译时编译器往往不能知道函数是否会改变其所指变量的值，因此从语法上就规避掉了这个危险。 如果函数的形参是指向const型变量的指针，那么实参可以是指向const变量的值，也同时是指向非const变量的指针，可以是const变量的地址，也可以是非const变量的地址。这个很好理解，由于形参是指向const型变量的指针，那么在函数调用的过程中，永远不会改变其所指对象的值。因此实参用const类型的地址当然是没问题的，用非const类型的地址更没问题。非const类型可没说一定要改，不改当然也没问题。 5.2 引用 如果形参是普通的引用，那么实参必须传递一个普通的变量地址或者普通的引用，不能传递const引用，这点和指针的情况一样 如果形参是const引用，那么实参既可以是普通的变量地址或普通的引用，也可以是const引用 6 总结const这个关键字，一般用来保护数据。体现在两个方面： 第一个方面，用于声明const常量或者常对象，由于不可改变的属性，可以用来保护数据本身不被更改； 第二个方面，在于函数调用这一块。C++中，尤其是面向对象的时候，传址是更简洁有效的，这样不会需要临时的存储空间。但是传址会存在一个问题，那就是遇到不想改变的值，会有风险。于是就有了指向常变量（常对象）的指针，和常引用。 如果需要保证数据在调用函数的过程中不被改变，需要将函数的形参声明为const指针或者引用，这样传址过来可以保证在函数调用的时候不会改变。如果需要保证数据在整个程序都不会改变，则需要将函数的形参声明为const，并且实参也应该声明为const，这样可以万无一失了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"hxblog.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"hxblog.top/tags/C/"}]},{"title":"C++笔记：类初步","slug":"C-笔记：类初步","date":"2018-05-24T08:15:49.000Z","updated":"2018-06-07T16:11:25.000Z","comments":true,"path":"post/bd44de2.html","link":"","permalink":"hxblog.top/post/bd44de2.html","excerpt":"类初步：基本概念","text":"类初步：基本概念 1 类的成员的两种类型类的数据和成员函数有两种类型，public和private。 一般数据设为私有，对外的成员函数为公共的，某些类自己使用的函数定义为私有。 目标就是为了隐蔽性。 2 声明和使用声明： class Time{ private: ... public: ... }; 注意： i. class是关键字，说明这是类，和结构体的struct一样 ii.private和public注意后面有个冒号 iii.声明完类后有个分号 iv.类一般首字母大写，建议，非强制 使用： Time t; 3 类和结构体的区别：类：默认为私有private 结构体：默认为公共public 4 成员函数一般成员函数在类体里面声明，在体外定义。 这样可以避免重复定义，比如多个文件用到这个类时，会出现重复定义。 此外，有助于接口与实现细节的分离。 5 类声明与成员函数定义的分离通常，将类的声明写在头文件中（.h），将但是对成员函数的定义一般不放在头文件（.h）中，放在另一个.cpp文件中。如果用户想用该类，只需要把头文件包含进来即可。通常的做法： 头文件：类的声明，包括数据成员的定义和方法的声明 //头文件 #include clas T{ public: void display();//公用成员函数声明 }; 成员函数定义： //display.cpp #include \"T.h\"//必须 #include void T::display(){ ... } 主函数： #include #include \"T.h\" int main(){ T t1; t1.display(); return 0; } 成员函数放在单独的文件里有如下好处：如果一个类被多次使用，那么每次使用时不必编译这个类的成员函数。成员函数只要编译一次即可。生成的目标文件可以重复使用。 6 类库通常将多个类放在一个头文件中，形成类库。 类库包含两个部分：类声明头文件，已经编译的成员函数的定义，它是目标文件。 7 对象的存储空间对象的存储空间只包括数据，不包括成员函数。成员函数的代码是存储在对象空间之外的。如果定义了2个对象，则2个对象的成员函数对应的是同一个函数代码段。 注意： 不论成员函数在类体里面定义还是在类外定义，其代码段都不占用对象的存储空间。 不论是否使用inline函数，成员函数代码段都不占用对象的存储空间。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"hxblog.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"hxblog.top/tags/C/"}]},{"title":"C++笔记：引用","slug":"C-笔记：引用","date":"2018-05-21T08:06:07.000Z","updated":"2018-06-07T16:11:25.000Z","comments":true,"path":"post/f2f456f3.html","link":"","permalink":"hxblog.top/post/f2f456f3.html","excerpt":"引用即别名","text":"引用即别名 1. 含义引用即别名。这是理解引用的核心。a是一个变量，b是a的引用，你不论是对a还是b踢了一脚，这两人都得受伤。新建一个变量的引用，实际上就是对原来变量取了个别名，因此这一操作不会开辟内存空间，这是和指针的根本区别。定义指针指向一个变量是要开辟内存空间的，那个空间里存放的是指向那个变量的地址。 2. 用法[类型] & [别名]=[需要引用的变量] 括号内的都是可以改变的。例如： int x = 10; int y = 20; int & b = x; int & c = b; //这是正确的，可以给一个家伙起两个别名，也可以给已经有别名的家伙起个别名 int & b = y; //这是错误的，不能把一个别名用在两个人身上 3. 注意点a) 引用的类型必须要和被引用的类型一致，给一个汉子起个娘炮的名字想必是不合适的。有例外，那就是引入const字符。 b) 引用在定义的时候就必须要初始化（应用在函数中有例外） c) 可以建立指针变量的引用，但不能定义指向引用类型的指针变量 例如 int a=10; int & b=a; int *p = &a; int * & pp =p;//正确，指针也是人，当然有起别名的权利 int & *ppp =&a;//错误，不能定义指向引用类型的指针变量，因为你都不知道这个逗逼是个什么人 //注意，引用可不是个具体的人，你无法用指针指向这个你都不知道的家伙 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"hxblog.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"hxblog.top/tags/C/"}]},{"title":"C++笔记：内联函数","slug":"C-笔记：内联函数","date":"2018-05-18T03:13:45.000Z","updated":"2018-06-07T16:11:25.000Z","comments":true,"path":"post/83f66acc.html","link":"","permalink":"hxblog.top/post/83f66acc.html","excerpt":"内联函数类似于宏（define），起直接替换的作用，但是两者有很大区别，最主要的区别是内联函数采用值传递。","text":"内联函数类似于宏（define），起直接替换的作用，但是两者有很大区别，最主要的区别是内联函数采用值传递。 1. 内联函数的意义为一些简单的函数起直接替换的作用，免得一直需要去访问栈空间（函数）。 2. 适用场合函数简单，不占内存的情况 3. 特点值传递，先算值，再代入，区别宏 4. 例子#define SQUARE(x) x*x 这里是将x*x直接代入 a=SQUARE(1+2); 实际a=1+2*1+2 inline square(double x){ return x*x; } a=square(1+2); 实际a=(1+2)*(1+2); 采用的是值传递，这一点和普通函数一样。当然函数可以值传递，也可以址传递，还可以引用传递 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"C++","slug":"C","permalink":"hxblog.top/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"hxblog.top/tags/C/"}]}]}